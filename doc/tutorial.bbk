<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN" "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<article id="tutorial" last-revision="$Date: 2016/08/05 20:23:25 $" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Boost.Python Tutorial</title>
  <articleinfo>
    <authorgroup>
    <author>
      <firstname>Joel</firstname> <surname>de Guzman</surname>
    </author>
    <author>
      <firstname>David</firstname> <surname>Abrahams</surname>
    </author>
    </authorgroup>
    <copyright>
      <year>2002</year> <year>2003</year> <year>2004</year> <year>2005</year> <holder>Joel
      de Guzman, David Abrahams</holder>
    </copyright>
    <legalnotice id="tutorial.legal">
      <para>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <ulink url="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>
      </para>
    </legalnotice>
    <articlepurpose>
      Reflects C++ classes and functions into Python
    </articlepurpose>
    <articlecategory name="category:inter-language support"></articlecategory>
  </articleinfo>
  <section id="tutorial.quickstart">
    <title><link linkend="tutorial.quickstart">QuickStart</link></title>
    <para>
      The Boost Python Library is a framework for interfacing Python and C++. It
      allows you to quickly and seamlessly expose C++ classes functions and objects
      to Python, and vice-versa, using no special tools -- just your C++ compiler.
      It is designed to wrap C++ interfaces non-intrusively, so that you should not
      have to change the C++ code at all in order to wrap it, making Boost.Python
      ideal for exposing 3rd-party libraries to Python. The library's use of advanced
      metaprogramming techniques simplifies its syntax for users, so that wrapping
      code takes on the look of a kind of declarative interface definition language
      (IDL).
    </para>
    <bridgehead renderas="sect2" id="tutorial.quickstart.h0">
      <phrase id="tutorial.quickstart.hello_world"/><link linkend="tutorial.quickstart.hello_world">Hello
      World</link>
    </bridgehead>
    <para>
      Following C/C++ tradition, let's start with the &quot;hello, world&quot;. A
      C++ Function:
    </para>
<programlisting><phrase role="keyword">char</phrase> <phrase role="keyword">const</phrase><phrase role="special">*</phrase> <phrase role="identifier">greet</phrase><phrase role="special">()</phrase>
<phrase role="special">{</phrase>
   <phrase role="keyword">return</phrase> <phrase role="string">&quot;hello, world&quot;</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
</programlisting>
    <para>
      can be exposed to Python by writing a Boost.Python wrapper:
    </para>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">python</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">hello_ext</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">python</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;greet&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">greet</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase>
</programlisting>
    <para>
      That's it. We're done. We can now build this as a shared library. The resulting
      DLL is now visible to Python. Here's a sample Python session:
    </para>
<programlisting><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">import</phrase> <phrase role="identifier">hello_ext</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">print</phrase> <phrase role="identifier">hello_ext</phrase><phrase role="special">.</phrase><phrase role="identifier">greet</phrase><phrase role="special">()</phrase>
<phrase role="identifier">hello</phrase><phrase role="special">,</phrase> <phrase role="identifier">world</phrase>
</programlisting>
    <blockquote>
      <para>
        <emphasis><emphasis role="bold">Next stop... Building your Hello World module
        from start to finish...</emphasis></emphasis>
      </para>
    </blockquote>
  </section>
  <section id="tutorial.hello">
    <title><link linkend="tutorial.hello">Building Hello World</link></title>
    <bridgehead renderas="sect2" id="tutorial.hello.h0">
      <phrase id="tutorial.hello.from_start_to_finish"/><link linkend="tutorial.hello.from_start_to_finish">From
      Start To Finish</link>
    </bridgehead>
    <para>
      Now the first thing you'd want to do is to build the Hello World module and
      try it for yourself in Python. In this section, we will outline the steps necessary
      to achieve that. We will use the build tool that comes bundled with every boost
      distribution: <emphasis role="bold">bjam</emphasis>.
    </para>
    <note>
      <para>
        <emphasis role="bold">Building without bjam</emphasis>
      </para>
      <para>
        Besides bjam, there are of course other ways to get your module built. What's
        written here should not be taken as &quot;the one and only way&quot;. There
        are of course other build tools apart from <literal>bjam</literal>.
      </para>
      <para>
        Take note however that the preferred build tool for Boost.Python is bjam.
        There are so many ways to set up the build incorrectly. Experience shows
        that 90% of the &quot;I can't build Boost.Python&quot; problems come from
        people who had to use a different tool.
      </para>
    </note>
    <para>
      We will skip over the details. Our objective will be to simply create the hello
      world module and run it in Python. For a complete reference to building Boost.Python,
      check out: <ulink url="../../../building.html">building.html</ulink>. After
      this brief <emphasis>bjam</emphasis> tutorial, we should have built the DLLs
      and run a python program using the extension.
    </para>
    <para>
      The tutorial example can be found in the directory: <literal>libs/python/example/tutorial</literal>.
      There, you can find:
    </para>
    <itemizedlist>
      <listitem>
        <simpara>
          hello.cpp
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          hello.py
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          Jamroot
        </simpara>
      </listitem>
    </itemizedlist>
    <para>
      The <literal>hello.cpp</literal> file is our C++ hello world example. The
      <literal>Jamroot</literal> is a minimalist <emphasis>bjam</emphasis> script
      that builds the DLLs for us. Finally, <literal>hello.py</literal> is our Python
      program that uses the extension in <literal>hello.cpp</literal>.
    </para>
    <para>
      Before anything else, you should have the bjam executable in your boost directory
      or somewhere in your path such that <literal>bjam</literal> can be executed
      in the command line. Pre-built Boost.Jam executables are available for most
      platforms. The complete list of Bjam executables can be found <ulink url="http://sourceforge.net/project/showfiles.php?group_id=7586">here</ulink>.
    </para>
    <bridgehead renderas="sect2" id="tutorial.hello.h1">
      <phrase id="tutorial.hello.let_s_jam"/><link linkend="tutorial.hello.let_s_jam">Let's
      Jam!</link>
    </bridgehead>
    <para>
      <inlinemediaobject><imageobject><imagedata fileref="../images/jam.png"></imagedata></imageobject></inlinemediaobject>
    </para>
    <para>
      <ulink url="../../../../example/tutorial/Jamroot">Here</ulink> is our minimalist
      Jamroot file. Simply copy the file and tweak <literal>use-project boost</literal>
      to where your boost root directory is and you're OK.
    </para>
    <para>
      The comments contained in the Jamrules file above should be sufficient to get
      you going.
    </para>
    <bridgehead renderas="sect2" id="tutorial.hello.h2">
      <phrase id="tutorial.hello.running_bjam"/><link linkend="tutorial.hello.running_bjam">Running
      bjam</link>
    </bridgehead>
    <para>
      <emphasis>bjam</emphasis> is run using your operating system's command line
      interpreter.
    </para>
    <blockquote>
      <para>
        Start it up.
      </para>
    </blockquote>
    <para>
      A file called user-config.jam in your home directory is used to configure your
      tools. In Windows, your home directory can be found by typing:
    </para>
<programlisting>ECHO %HOMEDRIVE%%HOMEPATH%
</programlisting>
    <para>
      into a command prompt window. Your file should at least have the rules for
      your compiler and your python installation. A specific example of this on Windows
      would be:
    </para>
<programlisting>#  MSVC configuration
using msvc : 8.0 ;

#  Python configuration
using python : 2.4 : C:<emphasis>dev/tools/Python</emphasis> ;
</programlisting>
    <para>
      The first rule tells Bjam to use the MSVC 8.0 compiler and associated tools.
      The second rule provides information on Python, its version and where it is
      located. The above assumes that the Python installation is in <literal>C:<emphasis>dev/tools\/Python</emphasis></literal>.
      If you have one fairly &quot;standard&quot; python installation for your platform,
      you might not need to do this.
    </para>
    <para>
      Now we are ready... Be sure to <literal>cd</literal> to <literal>libs/python/example/tutorial</literal>
      where the tutorial <literal>&quot;hello.cpp&quot;</literal> and the <literal>&quot;Jamroot&quot;</literal>
      is situated.
    </para>
    <para>
      Finally:
    </para>
<programlisting><phrase role="identifier">bjam</phrase>
</programlisting>
    <para>
      It should be building now:
    </para>
<programlisting>cd C:\dev\boost\libs\python\example\tutorial
bjam
...patience...
...found 1101 targets...
...updating 35 targets...
</programlisting>
    <para>
      And so on... Finally:
    </para>
<programlisting>   Creating library <emphasis>path-to-boost_python.dll</emphasis>
   Creating library /path-to-<!--quickbook-escape-prefix-->hello_ext<!--quickbook-escape-postfix-->.exp/
<!--quickbook-escape-prefix-->**passed**<!--quickbook-escape-postfix--> ... hello.test
...updated 35 targets...
</programlisting>
    <para>
      Or something similar. If all is well, you should now have built the DLLs and
      run the Python program.
    </para>
    <blockquote>
      <para>
        <emphasis role="bold">There you go... Have fun!</emphasis>
      </para>
    </blockquote>
  </section>
  <section id="tutorial.exposing">
    <title><link linkend="tutorial.exposing">Exposing Classes</link></title>
    <para>
      Now let's expose a C++ class to Python.
    </para>
    <para>
      Consider a C++ class/struct that we want to expose to Python:
    </para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">World</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">set</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">msg</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase> <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">msg</phrase> <phrase role="special">=</phrase> <phrase role="identifier">msg</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
    <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">greet</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">msg</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
    <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">msg</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
    <para>
      We can expose this to Python by writing a corresponding Boost.Python C++ Wrapper:
    </para>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">python</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">python</phrase><phrase role="special">;</phrase>

<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">hello</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">World</phrase><phrase role="special">&gt;(</phrase><phrase role="string">&quot;World&quot;</phrase><phrase role="special">)</phrase>
        <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;greet&quot;</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">World</phrase><phrase role="special">::</phrase><phrase role="identifier">greet</phrase><phrase role="special">)</phrase>
        <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;set&quot;</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">World</phrase><phrase role="special">::</phrase><phrase role="identifier">set</phrase><phrase role="special">)</phrase>
    <phrase role="special">;</phrase>
<phrase role="special">}</phrase>
</programlisting>
    <para>
      Here, we wrote a C++ class wrapper that exposes the member functions <literal>greet</literal>
      and <literal>set</literal>. Now, after building our module as a shared library,
      we may use our class <literal>World</literal> in Python. Here's a sample Python
      session:
    </para>
<programlisting><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">import</phrase> <phrase role="identifier">hello</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">planet</phrase> <phrase role="special">=</phrase> <phrase role="identifier">hello</phrase><phrase role="special">.</phrase><phrase role="identifier">World</phrase><phrase role="special">()</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">planet</phrase><phrase role="special">.</phrase><phrase role="identifier">set</phrase><phrase role="special">(</phrase><phrase role="string">'howdy'</phrase><phrase role="special">)</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">planet</phrase><phrase role="special">.</phrase><phrase role="identifier">greet</phrase><phrase role="special">()</phrase>
<phrase role="string">'howdy'</phrase>
</programlisting>
    <section id="tutorial.exposing.constructors">
      <title><link linkend="tutorial.exposing.constructors">Constructors</link></title>
      <para>
        Our previous example didn't have any explicit constructors. Since <literal>World</literal>
        is declared as a plain struct, it has an implicit default constructor. Boost.Python
        exposes the default constructor by default, which is why we were able to
        write
      </para>
<programlisting><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">planet</phrase> <phrase role="special">=</phrase> <phrase role="identifier">hello</phrase><phrase role="special">.</phrase><phrase role="identifier">World</phrase><phrase role="special">()</phrase>
</programlisting>
      <para>
        We may wish to wrap a class with a non-default constructor. Let us build
        on our previous example:
      </para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">World</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">World</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">msg</phrase><phrase role="special">):</phrase> <phrase role="identifier">msg</phrase><phrase role="special">(</phrase><phrase role="identifier">msg</phrase><phrase role="special">)</phrase> <phrase role="special">{}</phrase> <phrase role="comment">// added constructor</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">set</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">msg</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase> <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">msg</phrase> <phrase role="special">=</phrase> <phrase role="identifier">msg</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
    <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">greet</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">msg</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
    <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">msg</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        This time <literal>World</literal> has no default constructor; our previous
        wrapping code would fail to compile when the library tried to expose it.
        We have to tell <literal>class_&lt;World&gt;</literal> about the constructor
        we want to expose instead.
      </para>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">python</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">python</phrase><phrase role="special">;</phrase>

<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">hello</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">World</phrase><phrase role="special">&gt;(</phrase><phrase role="string">&quot;World&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">init</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">&gt;())</phrase>
        <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;greet&quot;</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">World</phrase><phrase role="special">::</phrase><phrase role="identifier">greet</phrase><phrase role="special">)</phrase>
        <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;set&quot;</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">World</phrase><phrase role="special">::</phrase><phrase role="identifier">set</phrase><phrase role="special">)</phrase>
    <phrase role="special">;</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        <literal>init&lt;std::string&gt;()</literal> exposes the constructor taking
        in a <literal>std::string</literal> (in Python, constructors are spelled
        &quot;<literal>&quot;__init__&quot;</literal>&quot;).
      </para>
      <para>
        We can expose additional constructors by passing more <literal>init&lt;...&gt;</literal>s
        to the <literal>def()</literal> member function. Say for example we have
        another World constructor taking in two doubles:
      </para>
<programlisting><phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">World</phrase><phrase role="special">&gt;(</phrase><phrase role="string">&quot;World&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">init</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">&gt;())</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">init</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">double</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase><phrase role="special">&gt;())</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;greet&quot;</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">World</phrase><phrase role="special">::</phrase><phrase role="identifier">greet</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;set&quot;</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">World</phrase><phrase role="special">::</phrase><phrase role="identifier">set</phrase><phrase role="special">)</phrase>
<phrase role="special">;</phrase>
</programlisting>
      <para>
        On the other hand, if we do not wish to expose any constructors at all, we
        may use <literal>no_init</literal> instead:
      </para>
<programlisting><phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Abstract</phrase><phrase role="special">&gt;(</phrase><phrase role="string">&quot;Abstract&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">no_init</phrase><phrase role="special">)</phrase>
</programlisting>
      <para>
        This actually adds an <literal>__init__</literal> method which always raises
        a Python RuntimeError exception.
      </para>
    </section>
    <section id="tutorial.exposing.class_data_members">
      <title><link linkend="tutorial.exposing.class_data_members">Class Data Members</link></title>
      <para>
        Data members may also be exposed to Python so that they can be accessed as
        attributes of the corresponding Python class. Each data member that we wish
        to be exposed may be regarded as <emphasis role="bold">read-only</emphasis>
        or <emphasis role="bold">read-write</emphasis>. Consider this class <literal>Var</literal>:
      </para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">Var</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">Var</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">name</phrase><phrase role="special">)</phrase> <phrase role="special">:</phrase> <phrase role="identifier">name</phrase><phrase role="special">(</phrase><phrase role="identifier">name</phrase><phrase role="special">),</phrase> <phrase role="identifier">value</phrase><phrase role="special">()</phrase> <phrase role="special">{}</phrase>
    <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">name</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">float</phrase> <phrase role="identifier">value</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        Our C++ <literal>Var</literal> class and its data members can be exposed
        to Python:
      </para>
<programlisting><phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Var</phrase><phrase role="special">&gt;(</phrase><phrase role="string">&quot;Var&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">init</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">&gt;())</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def_readonly</phrase><phrase role="special">(</phrase><phrase role="string">&quot;name&quot;</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">Var</phrase><phrase role="special">::</phrase><phrase role="identifier">name</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def_readwrite</phrase><phrase role="special">(</phrase><phrase role="string">&quot;value&quot;</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">Var</phrase><phrase role="special">::</phrase><phrase role="identifier">value</phrase><phrase role="special">);</phrase>
</programlisting>
      <para>
        Then, in Python, assuming we have placed our Var class inside the namespace
        hello as we did before:
      </para>
<programlisting><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">hello</phrase><phrase role="special">.</phrase><phrase role="identifier">Var</phrase><phrase role="special">(</phrase><phrase role="string">'pi'</phrase><phrase role="special">)</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">value</phrase> <phrase role="special">=</phrase> <phrase role="number">3.14</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">print</phrase> <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">name</phrase><phrase role="special">,</phrase> <phrase role="string">'is around'</phrase><phrase role="special">,</phrase> <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">value</phrase>
<phrase role="identifier">pi</phrase> <phrase role="keyword">is</phrase> <phrase role="identifier">around</phrase> <phrase role="number">3.14</phrase>
</programlisting>
      <para>
        Note that <literal>name</literal> is exposed as <emphasis role="bold">read-only</emphasis>
        while <literal>value</literal> is exposed as <emphasis role="bold">read-write</emphasis>.
      </para>
<programlisting><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">name</phrase> <phrase role="special">=</phrase> <phrase role="string">'e'</phrase> <phrase role="comment"># can't change name</phrase>
<phrase role="identifier">Traceback</phrase> <phrase role="special">(</phrase><phrase role="identifier">most</phrase> <phrase role="identifier">recent</phrase> <phrase role="identifier">call</phrase> <phrase role="identifier">last</phrase><phrase role="special">):</phrase>
  <phrase role="identifier">File</phrase> <phrase role="string">&quot;&lt;stdin&gt;&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">line</phrase> <phrase role="number">1</phrase><phrase role="special">,</phrase> <phrase role="keyword">in</phrase> <phrase role="error">?</phrase>
<phrase role="identifier">AttributeError</phrase><phrase role="special">:</phrase> <phrase role="identifier">can</phrase><phrase role="error">'</phrase><phrase role="identifier">t</phrase> <phrase role="identifier">set</phrase> <phrase role="identifier">attribute</phrase>
</programlisting>
    </section>
    <section id="tutorial.exposing.class_properties">
      <title><link linkend="tutorial.exposing.class_properties">Class Properties</link></title>
      <para>
        In C++, classes with public data members are usually frowned upon. Well designed
        classes that take advantage of encapsulation hide the class' data members.
        The only way to access the class' data is through access (getter/setter)
        functions. Access functions expose class properties. Here's an example:
      </para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">Num</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">Num</phrase><phrase role="special">();</phrase>
    <phrase role="keyword">float</phrase> <phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">set</phrase><phrase role="special">(</phrase><phrase role="keyword">float</phrase> <phrase role="identifier">value</phrase><phrase role="special">);</phrase>
    <phrase role="special">...</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        However, in Python attribute access is fine; it doesn't neccessarily break
        encapsulation to let users handle attributes directly, because the attributes
        can just be a different syntax for a method call. Wrapping our <literal>Num</literal>
        class using Boost.Python:
      </para>
<programlisting><phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Num</phrase><phrase role="special">&gt;(</phrase><phrase role="string">&quot;Num&quot;</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">add_property</phrase><phrase role="special">(</phrase><phrase role="string">&quot;rovalue&quot;</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">Num</phrase><phrase role="special">::</phrase><phrase role="identifier">get</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">add_property</phrase><phrase role="special">(</phrase><phrase role="string">&quot;value&quot;</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">Num</phrase><phrase role="special">::</phrase><phrase role="identifier">get</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">Num</phrase><phrase role="special">::</phrase><phrase role="identifier">set</phrase><phrase role="special">);</phrase>
</programlisting>
      <para>
        And at last, in Python:
      </para>
<programlisting><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">Num</phrase><phrase role="special">()</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">value</phrase> <phrase role="special">=</phrase> <phrase role="number">3.14</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">value</phrase><phrase role="special">,</phrase> <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">rovalue</phrase>
<phrase role="special">(</phrase><phrase role="number">3.14</phrase><phrase role="special">,</phrase> <phrase role="number">3.14</phrase><phrase role="special">)</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">rovalue</phrase> <phrase role="special">=</phrase> <phrase role="number">2.17</phrase> <phrase role="comment"># error!</phrase>
</programlisting>
      <para>
        Take note that the class property <literal>rovalue</literal> is exposed as
        <emphasis role="bold">read-only</emphasis> since the <literal>rovalue</literal>
        setter member function is not passed in:
      </para>
<programlisting><phrase role="special">.</phrase><phrase role="identifier">add_property</phrase><phrase role="special">(</phrase><phrase role="string">&quot;rovalue&quot;</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">Num</phrase><phrase role="special">::</phrase><phrase role="identifier">get</phrase><phrase role="special">)</phrase>
</programlisting>
    </section>
    <section id="tutorial.exposing.inheritance">
      <title><link linkend="tutorial.exposing.inheritance">Inheritance</link></title>
      <para>
        In the previous examples, we dealt with classes that are not polymorphic.
        This is not often the case. Much of the time, we will be wrapping polymorphic
        classes and class hierarchies related by inheritance. We will often have
        to write Boost.Python wrappers for classes that are derived from abstract
        base classes.
      </para>
      <para>
        Consider this trivial inheritance structure:
      </para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">Base</phrase> <phrase role="special">{</phrase> <phrase role="keyword">virtual</phrase> <phrase role="special">~</phrase><phrase role="identifier">Base</phrase><phrase role="special">();</phrase> <phrase role="special">};</phrase>
<phrase role="keyword">struct</phrase> <phrase role="identifier">Derived</phrase> <phrase role="special">:</phrase> <phrase role="identifier">Base</phrase> <phrase role="special">{};</phrase>
</programlisting>
      <para>
        And a set of C++ functions operating on <literal>Base</literal> and <literal>Derived</literal>
        object instances:
      </para>
<programlisting><phrase role="keyword">void</phrase> <phrase role="identifier">b</phrase><phrase role="special">(</phrase><phrase role="identifier">Base</phrase><phrase role="special">*);</phrase>
<phrase role="keyword">void</phrase> <phrase role="identifier">d</phrase><phrase role="special">(</phrase><phrase role="identifier">Derived</phrase><phrase role="special">*);</phrase>
<phrase role="identifier">Base</phrase><phrase role="special">*</phrase> <phrase role="identifier">factory</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="keyword">new</phrase> <phrase role="identifier">Derived</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
</programlisting>
      <para>
        We've seen how we can wrap the base class <literal>Base</literal>:
      </para>
<programlisting><phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">&gt;(</phrase><phrase role="string">&quot;Base&quot;</phrase><phrase role="special">)</phrase>
    <phrase role="comment">/*...*/</phrase>
    <phrase role="special">;</phrase>
</programlisting>
      <para>
        Now we can inform Boost.Python of the inheritance relationship between <literal>Derived</literal>
        and its base class <literal>Base</literal>. Thus:
      </para>
<programlisting><phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Derived</phrase><phrase role="special">,</phrase> <phrase role="identifier">bases</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;(</phrase><phrase role="string">&quot;Derived&quot;</phrase><phrase role="special">)</phrase>
    <phrase role="comment">/*...*/</phrase>
    <phrase role="special">;</phrase>
</programlisting>
      <para>
        Doing so, we get some things for free:
      </para>
      <orderedlist>
        <listitem>
          <simpara>
            Derived automatically inherits all of Base's Python methods (wrapped
            C++ member functions)
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <emphasis role="bold">If</emphasis> Base is polymorphic, <literal>Derived</literal>
            objects which have been passed to Python via a pointer or reference to
            <literal>Base</literal> can be passed where a pointer or reference to
            <literal>Derived</literal> is expected.
          </simpara>
        </listitem>
      </orderedlist>
      <para>
        Now, we will expose the C++ free functions <literal>b</literal> and <literal>d</literal>
        and <literal>factory</literal>:
      </para>
<programlisting><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;b&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">b</phrase><phrase role="special">);</phrase>
<phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;d&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">d</phrase><phrase role="special">);</phrase>
<phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;factory&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">factory</phrase><phrase role="special">);</phrase>
</programlisting>
      <para>
        Note that free function <literal>factory</literal> is being used to generate
        new instances of class <literal>Derived</literal>. In such cases, we use
        <literal>return_value_policy&lt;manage_new_object&gt;</literal> to instruct
        Python to adopt the pointer to <literal>Base</literal> and hold the instance
        in a new Python <literal>Base</literal> object until the the Python object
        is destroyed. We will see more of Boost.Python <link linkend="tutorial.functions.call_policies">call
        policies</link> later.
      </para>
<programlisting><phrase role="comment">// Tell Python to take ownership of factory's result</phrase>
<phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;factory&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">factory</phrase><phrase role="special">,</phrase>
    <phrase role="identifier">return_value_policy</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">manage_new_object</phrase><phrase role="special">&gt;());</phrase>
</programlisting>
    </section>
    <section id="tutorial.exposing.class_virtual_functions">
      <title><link linkend="tutorial.exposing.class_virtual_functions">Class Virtual
      Functions</link></title>
      <para>
        In this section, we will learn how to make functions behave polymorphically
        through virtual functions. Continuing our example, let us add a virtual function
        to our <literal>Base</literal> class:
      </para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">Base</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">virtual</phrase> <phrase role="special">~</phrase><phrase role="identifier">Base</phrase><phrase role="special">()</phrase> <phrase role="special">{}</phrase>
    <phrase role="keyword">virtual</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">f</phrase><phrase role="special">()</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        One of the goals of Boost.Python is to be minimally intrusive on an existing
        C++ design. In principle, it should be possible to expose the interface for
        a 3rd party library without changing it. It is not ideal to add anything
        to our class <code><phrase role="identifier">Base</phrase></code>. Yet, when
        you have a virtual function that's going to be overridden in Python and called
        polymorphically <emphasis role="bold">from C++</emphasis>, we'll need to
        add some scaffoldings to make things work properly. What we'll do is write
        a class wrapper that derives from <code><phrase role="identifier">Base</phrase></code>
        that will unintrusively hook into the virtual functions so that a Python
        override may be called:
      </para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">BaseWrap</phrase> <phrase role="special">:</phrase> <phrase role="identifier">Base</phrase><phrase role="special">,</phrase> <phrase role="identifier">wrapper</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">&gt;</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">int</phrase> <phrase role="identifier">f</phrase><phrase role="special">()</phrase>
    <phrase role="special">{</phrase>
        <phrase role="keyword">return</phrase> <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">get_override</phrase><phrase role="special">(</phrase><phrase role="string">&quot;f&quot;</phrase><phrase role="special">)();</phrase>
    <phrase role="special">}</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        Notice too that in addition to inheriting from <code><phrase role="identifier">Base</phrase></code>,
        we also multiply- inherited <code><phrase role="identifier">wrapper</phrase><phrase
        role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase
        role="special">&gt;</phrase></code> (See <ulink url="../reference/high_level_components/boost_python_wrapper_hpp.html#high_level_components.boost_python_wrapper_hpp.class_template_wrapper">Wrapper</ulink>).
        The <code><phrase role="identifier">wrapper</phrase></code> template makes
        the job of wrapping classes that are meant to overridden in Python, easier.
      </para>
      <sidebar role="blurb">
      <para>
        <inlinemediaobject><imageobject><imagedata fileref="../images/alert.png"></imagedata></imageobject></inlinemediaobject>
        <emphasis role="bold">MSVC6/7 Workaround</emphasis>
      </para>
      <para>
        If you are using Microsoft Visual C++ 6 or 7, you have to write <code><phrase
        role="identifier">f</phrase></code> as:
      </para>
      <para>
        <code><phrase role="keyword">return</phrase> <phrase role="identifier">call</phrase><phrase
        role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">&gt;(</phrase><phrase
        role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase
        role="identifier">get_override</phrase><phrase role="special">(</phrase><phrase
        role="string">&quot;f&quot;</phrase><phrase role="special">).</phrase><phrase
        role="identifier">ptr</phrase><phrase role="special">());</phrase></code>.
      </para>
      </sidebar>
      <para>
        BaseWrap's overridden virtual member function <code><phrase role="identifier">f</phrase></code>
        in effect calls the corresponding method of the Python object through <code><phrase
        role="identifier">get_override</phrase></code>.
      </para>
      <para>
        Finally, exposing <code><phrase role="identifier">Base</phrase></code>:
      </para>
<programlisting><phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">BaseWrap</phrase><phrase role="special">,</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">noncopyable</phrase><phrase role="special">&gt;(</phrase><phrase role="string">&quot;Base&quot;</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;f&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">pure_virtual</phrase><phrase role="special">(&amp;</phrase><phrase role="identifier">Base</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">))</phrase>
    <phrase role="special">;</phrase>
</programlisting>
      <para>
        <code><phrase role="identifier">pure_virtual</phrase></code> signals Boost.Python
        that the function <code><phrase role="identifier">f</phrase></code> is a
        pure virtual function.
      </para>
      <note>
        <para>
          <emphasis role="bold">member function and methods</emphasis>
        </para>
        <para>
          Python, like many object oriented languages uses the term <emphasis role="bold">methods</emphasis>.
          Methods correspond roughly to C++'s <emphasis role="bold">member functions</emphasis>
        </para>
      </note>
    </section>
    <section id="tutorial.exposing.virtual_functions_with_default_i">
      <title><link linkend="tutorial.exposing.virtual_functions_with_default_i">Virtual
      Functions with Default Implementations</link></title>
      <para>
        We've seen in the previous section how classes with pure virtual functions
        are wrapped using Boost.Python's <ulink url="../reference/high_level_components/boost_python_wrapper_hpp.html#high_level_components.boost_python_wrapper_hpp.class_template_wrapper">class
        wrapper</ulink> facilities. If we wish to wrap <emphasis role="bold">non</emphasis>-pure-virtual
        functions instead, the mechanism is a bit different.
      </para>
      <para>
        Recall that in the <link linkend="tutorial.exposing.class_virtual_functions">previous
        section</link>, we wrapped a class with a pure virtual function that we then
        implemented in C++, or Python classes derived from it. Our base class:
      </para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">Base</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">virtual</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">f</phrase><phrase role="special">()</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        had a pure virtual function <literal>f</literal>. If, however, its member
        function <literal>f</literal> was not declared as pure virtual:
      </para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">Base</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">virtual</phrase> <phrase role="special">~</phrase><phrase role="identifier">Base</phrase><phrase role="special">()</phrase> <phrase role="special">{}</phrase>
    <phrase role="keyword">virtual</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">f</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        We wrap it this way:
      </para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">BaseWrap</phrase> <phrase role="special">:</phrase> <phrase role="identifier">Base</phrase><phrase role="special">,</phrase> <phrase role="identifier">wrapper</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">&gt;</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">int</phrase> <phrase role="identifier">f</phrase><phrase role="special">()</phrase>
    <phrase role="special">{</phrase>
        <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="identifier">override</phrase> <phrase role="identifier">f</phrase> <phrase role="special">=</phrase> <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">get_override</phrase><phrase role="special">(</phrase><phrase role="string">&quot;f&quot;</phrase><phrase role="special">))</phrase>
            <phrase role="keyword">return</phrase> <phrase role="identifier">f</phrase><phrase role="special">();</phrase> <phrase role="comment">// *note*</phrase>
        <phrase role="keyword">return</phrase> <phrase role="identifier">Base</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">();</phrase>
    <phrase role="special">}</phrase>

    <phrase role="keyword">int</phrase> <phrase role="identifier">default_f</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">();</phrase> <phrase role="special">}</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        Notice how we implemented <code><phrase role="identifier">BaseWrap</phrase><phrase
        role="special">::</phrase><phrase role="identifier">f</phrase></code>. Now,
        we have to check if there is an override for <code><phrase role="identifier">f</phrase></code>.
        If none, then we call <code><phrase role="identifier">Base</phrase><phrase
        role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">()</phrase></code>.
      </para>
      <sidebar role="blurb">
      <para>
        <inlinemediaobject><imageobject><imagedata fileref="../images/alert.png"></imagedata></imageobject></inlinemediaobject>
        <emphasis role="bold">MSVC6/7 Workaround</emphasis>
      </para>
      <para>
        If you are using Microsoft Visual C++ 6 or 7, you have to rewrite the line
        with the <code><phrase role="special">*</phrase><phrase role="identifier">note</phrase><phrase
        role="special">*</phrase></code> as:
      </para>
      <para>
        <code><phrase role="keyword">return</phrase> <phrase role="identifier">call</phrase><phrase
        role="special">&lt;</phrase><phrase role="keyword">char</phrase> <phrase
        role="keyword">const</phrase><phrase role="special">*&gt;(</phrase><phrase
        role="identifier">f</phrase><phrase role="special">.</phrase><phrase role="identifier">ptr</phrase><phrase
        role="special">());</phrase></code>.
      </para>
      </sidebar>
      <para>
        Finally, exposing:
      </para>
<programlisting><phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">BaseWrap</phrase><phrase role="special">,</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">noncopyable</phrase><phrase role="special">&gt;(</phrase><phrase role="string">&quot;Base&quot;</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;f&quot;</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">Base</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">BaseWrap</phrase><phrase role="special">::</phrase><phrase role="identifier">default_f</phrase><phrase role="special">)</phrase>
    <phrase role="special">;</phrase>
</programlisting>
      <para>
        Take note that we expose both <code><phrase role="special">&amp;</phrase><phrase
        role="identifier">Base</phrase><phrase role="special">::</phrase><phrase
        role="identifier">f</phrase></code> and <code><phrase role="special">&amp;</phrase><phrase
        role="identifier">BaseWrap</phrase><phrase role="special">::</phrase><phrase
        role="identifier">default_f</phrase></code>. Boost.Python needs to keep track
        of 1) the dispatch function <literal>f</literal> and 2) the forwarding function
        to its default implementation <literal>default_f</literal>. There's a special
        <literal>def</literal> function for this purpose.
      </para>
      <para>
        In Python, the results would be as expected:
      </para>
<programlisting><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">base</phrase> <phrase role="special">=</phrase> <phrase role="identifier">Base</phrase><phrase role="special">()</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Derived</phrase><phrase role="special">(</phrase><phrase role="identifier">Base</phrase><phrase role="special">):</phrase>
<phrase role="special">...</phrase>     <phrase role="keyword">def</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">):</phrase>
<phrase role="special">...</phrase>         <phrase role="keyword">return</phrase> <phrase role="number">42</phrase>
<phrase role="special">...</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">derived</phrase> <phrase role="special">=</phrase> <phrase role="identifier">Derived</phrase><phrase role="special">()</phrase>
</programlisting>
      <para>
        Calling <literal>base.f()</literal>:
      </para>
<programlisting><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">base</phrase><phrase role="special">.</phrase><phrase role="identifier">f</phrase><phrase role="special">()</phrase>
<phrase role="number">0</phrase>
</programlisting>
      <para>
        Calling <literal>derived.f()</literal>:
      </para>
<programlisting><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">derived</phrase><phrase role="special">.</phrase><phrase role="identifier">f</phrase><phrase role="special">()</phrase>
<phrase role="number">42</phrase>
</programlisting>
    </section>
    <section id="tutorial.exposing.class_operators_special_function">
      <title><link linkend="tutorial.exposing.class_operators_special_function">Class
      Operators/Special Functions</link></title>
      <bridgehead renderas="sect2" id="tutorial.exposing.class_operators_special_function.h0">
        <phrase id="tutorial.exposing.class_operators_special_function.python_operators"/><link
        linkend="tutorial.exposing.class_operators_special_function.python_operators">Python
        Operators</link>
      </bridgehead>
      <para>
        C is well known for the abundance of operators. C++ extends this to the extremes
        by allowing operator overloading. Boost.Python takes advantage of this and
        makes it easy to wrap C++ operator-powered classes.
      </para>
      <para>
        Consider a file position class <literal>FilePos</literal> and a set of operators
        that take on FilePos instances:
      </para>
<programlisting><phrase role="keyword">class</phrase> <phrase role="identifier">FilePos</phrase> <phrase role="special">{</phrase> <phrase role="comment">/*...*/</phrase> <phrase role="special">};</phrase>

<phrase role="identifier">FilePos</phrase>     <phrase role="keyword">operator</phrase><phrase role="special">+(</phrase><phrase role="identifier">FilePos</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase><phrase role="special">);</phrase>
<phrase role="identifier">FilePos</phrase>     <phrase role="keyword">operator</phrase><phrase role="special">+(</phrase><phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="identifier">FilePos</phrase><phrase role="special">);</phrase>
<phrase role="keyword">int</phrase>         <phrase role="keyword">operator</phrase><phrase role="special">-(</phrase><phrase role="identifier">FilePos</phrase><phrase role="special">,</phrase> <phrase role="identifier">FilePos</phrase><phrase role="special">);</phrase>
<phrase role="identifier">FilePos</phrase>     <phrase role="keyword">operator</phrase><phrase role="special">-(</phrase><phrase role="identifier">FilePos</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase><phrase role="special">);</phrase>
<phrase role="identifier">FilePos</phrase><phrase role="special">&amp;</phrase>    <phrase role="keyword">operator</phrase><phrase role="special">+=(</phrase><phrase role="identifier">FilePos</phrase><phrase role="special">&amp;,</phrase> <phrase role="keyword">int</phrase><phrase role="special">);</phrase>
<phrase role="identifier">FilePos</phrase><phrase role="special">&amp;</phrase>    <phrase role="keyword">operator</phrase><phrase role="special">-=(</phrase><phrase role="identifier">FilePos</phrase><phrase role="special">&amp;,</phrase> <phrase role="keyword">int</phrase><phrase role="special">);</phrase>
<phrase role="keyword">bool</phrase>        <phrase role="keyword">operator</phrase><phrase role="special">&lt;(</phrase><phrase role="identifier">FilePos</phrase><phrase role="special">,</phrase> <phrase role="identifier">FilePos</phrase><phrase role="special">);</phrase>
</programlisting>
      <para>
        The class and the various operators can be mapped to Python rather easily
        and intuitively:
      </para>
<programlisting><phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">FilePos</phrase><phrase role="special">&gt;(</phrase><phrase role="string">&quot;FilePos&quot;</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase> <phrase role="special">+</phrase> <phrase role="keyword">int</phrase><phrase role="special">())</phrase>          <phrase role="comment">// __add__</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase><phrase role="special">()</phrase> <phrase role="special">+</phrase> <phrase role="identifier">self</phrase><phrase role="special">)</phrase>          <phrase role="comment">// __radd__</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase> <phrase role="special">-</phrase> <phrase role="identifier">self</phrase><phrase role="special">)</phrase>           <phrase role="comment">// __sub__</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase> <phrase role="special">-</phrase> <phrase role="keyword">int</phrase><phrase role="special">())</phrase>          <phrase role="comment">// __sub__</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase> <phrase role="special">+=</phrase> <phrase role="keyword">int</phrase><phrase role="special">())</phrase>         <phrase role="comment">// __iadd__</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase> <phrase role="special">-=</phrase> <phrase role="identifier">other</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">&gt;())</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">self</phrase><phrase role="special">);</phrase>          <phrase role="comment">// __lt__</phrase>
</programlisting>
      <para>
        The code snippet above is very clear and needs almost no explanation at all.
        It is virtually the same as the operators' signatures. Just take note that
        <literal>self</literal> refers to FilePos object. Also, not every class
        <literal>T</literal> that you might need to interact with in an operator
        expression is (cheaply) default-constructible. You can use <literal>other&lt;T&gt;()</literal>
        in place of an actual <literal>T</literal> instance when writing &quot;self
        expressions&quot;.
      </para>
      <bridgehead renderas="sect2" id="tutorial.exposing.class_operators_special_function.h1">
        <phrase id="tutorial.exposing.class_operators_special_function.special_methods"/><link
        linkend="tutorial.exposing.class_operators_special_function.special_methods">Special
        Methods</link>
      </bridgehead>
      <para>
        Python has a few more <emphasis>Special Methods</emphasis>. Boost.Python
        supports all of the standard special method names supported by real Python
        class instances. A similar set of intuitive interfaces can also be used to
        wrap C++ functions that correspond to these Python <emphasis>special functions</emphasis>.
        Example:
      </para>
<programlisting><phrase role="keyword">class</phrase> <phrase role="identifier">Rational</phrase>
<phrase role="special">{</phrase> <phrase role="keyword">public</phrase><phrase role="special">:</phrase> <phrase role="keyword">operator</phrase> <phrase role="keyword">double</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase> <phrase role="special">};</phrase>

<phrase role="identifier">Rational</phrase> <phrase role="identifier">pow</phrase><phrase role="special">(</phrase><phrase role="identifier">Rational</phrase><phrase role="special">,</phrase> <phrase role="identifier">Rational</phrase><phrase role="special">);</phrase>
<phrase role="identifier">Rational</phrase> <phrase role="identifier">abs</phrase><phrase role="special">(</phrase><phrase role="identifier">Rational</phrase><phrase role="special">);</phrase>
<phrase role="identifier">ostream</phrase><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">&lt;&lt;(</phrase><phrase role="identifier">ostream</phrase><phrase role="special">&amp;,</phrase><phrase role="identifier">Rational</phrase><phrase role="special">);</phrase>

<phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Rational</phrase><phrase role="special">&gt;(</phrase><phrase role="string">&quot;Rational&quot;</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">float_</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">))</phrase>                  <phrase role="comment">// __float__</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">pow</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">,</phrase> <phrase role="identifier">other</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Rational</phrase><phrase role="special">&gt;))</phrase>    <phrase role="comment">// __pow__</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">abs</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">))</phrase>                     <phrase role="comment">// __abs__</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">str</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">))</phrase>                     <phrase role="comment">// __str__</phrase>
    <phrase role="special">;</phrase>
</programlisting>
      <para>
        Need we say more?
      </para>
      <note>
        <para>
          What is the business of <code><phrase role="keyword">operator</phrase><phrase
          role="special">&lt;&lt;</phrase></code>? Well, the method <code><phrase
          role="identifier">str</phrase></code> requires the <code><phrase role="keyword">operator</phrase><phrase
          role="special">&lt;&lt;</phrase></code> to do its work (i.e. <code><phrase
          role="keyword">operator</phrase><phrase role="special">&lt;&lt;</phrase></code>
          is used by the method defined by <code><phrase role="identifier">def</phrase><phrase
          role="special">(</phrase><phrase role="identifier">str</phrase><phrase
          role="special">(</phrase><phrase role="identifier">self</phrase><phrase
          role="special">))</phrase></code>.
        </para>
      </note>
    </section>
  </section>
  <section id="tutorial.functions">
    <title><link linkend="tutorial.functions">Functions</link></title>
    <para>
      In this chapter, we'll look at Boost.Python powered functions in closer detail.
      We will see some facilities to make exposing C++ functions to Python safe from
      potential pifalls such as dangling pointers and references. We will also see
      facilities that will make it even easier for us to expose C++ functions that
      take advantage of C++ features such as overloading and default arguments.
    </para>
    <blockquote>
      <para>
        <emphasis>Read on...</emphasis>
      </para>
    </blockquote>
    <para>
      But before you do, you might want to fire up Python 2.2 or later and type
      <literal>&gt;&gt;&gt; import this</literal>.
    </para>
<programlisting>&gt;&gt;&gt; import this
The Zen of Python, by Tim Peters
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than <emphasis role="bold">right</emphasis> now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
</programlisting>
    <section id="tutorial.functions.call_policies">
      <title><link linkend="tutorial.functions.call_policies">Call Policies</link></title>
      <para>
        In C++, we often deal with arguments and return types such as pointers and
        references. Such primitive types are rather, ummmm, low level and they really
        don't tell us much. At the very least, we don't know the owner of the pointer
        or the referenced object. No wonder languages such as Java and Python never
        deal with such low level entities. In C++, it's usually considered a good
        practice to use smart pointers which exactly describe ownership semantics.
        Still, even good C++ interfaces use raw references and pointers sometimes,
        so Boost.Python must deal with them. To do this, it may need your help. Consider
        the following C++ function:
      </para>
<programlisting><phrase role="identifier">X</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">Y</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">,</phrase> <phrase role="identifier">Z</phrase><phrase role="special">*</phrase> <phrase role="identifier">z</phrase><phrase role="special">);</phrase>
</programlisting>
      <para>
        How should the library wrap this function? A naive approach builds a Python
        X object around result reference. This strategy might or might not work out.
        Here's an example where it didn't
      </para>
<programlisting><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">y</phrase><phrase role="special">,</phrase> <phrase role="identifier">z</phrase><phrase role="special">)</phrase> <phrase role="special">#</phrase> <phrase role="identifier">x</phrase> <phrase role="identifier">refers</phrase> <phrase role="identifier">to</phrase> <phrase role="identifier">some</phrase> <phrase role="identifier">C</phrase><phrase role="special">++</phrase> <phrase role="identifier">X</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">del</phrase> <phrase role="identifier">y</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">some_method</phrase><phrase role="special">()</phrase> <phrase role="special">#</phrase> <phrase role="identifier">CRASH</phrase><phrase role="special">!</phrase>
</programlisting>
      <para>
        What's the problem?
      </para>
      <para>
        Well, what if f() was implemented as shown below:
      </para>
<programlisting><phrase role="identifier">X</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">Y</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">,</phrase> <phrase role="identifier">Z</phrase><phrase role="special">*</phrase> <phrase role="identifier">z</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">y</phrase><phrase role="special">.</phrase><phrase role="identifier">z</phrase> <phrase role="special">=</phrase> <phrase role="identifier">z</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">return</phrase> <phrase role="identifier">y</phrase><phrase role="special">.</phrase><phrase role="identifier">x</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        The problem is that the lifetime of result X&amp; is tied to the lifetime
        of y, because the f() returns a reference to a member of the y object. This
        idiom is is not uncommon and perfectly acceptable in the context of C++.
        However, Python users should not be able to crash the system just by using
        our C++ interface. In this case deleting y will invalidate the reference
        to X. We have a dangling reference.
      </para>
      <para>
        Here's what's happening:
      </para>
      <orderedlist>
        <listitem>
          <simpara>
            <literal>f</literal> is called passing in a reference to <literal>y</literal>
            and a pointer to <literal>z</literal>
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            A reference to <literal>y.x</literal> is returned
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <literal>y</literal> is deleted. <literal>x</literal> is a dangling reference
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <literal>x.some_method()</literal> is called
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <emphasis role="bold">BOOM!</emphasis>
          </simpara>
        </listitem>
      </orderedlist>
      <para>
        We could copy result into a new object:
      </para>
<programlisting><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">y</phrase><phrase role="special">,</phrase> <phrase role="identifier">z</phrase><phrase role="special">).</phrase><phrase role="identifier">set</phrase><phrase role="special">(</phrase><phrase role="number">42</phrase><phrase role="special">)</phrase> <phrase role="comment"># Result disappears</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">y</phrase><phrase role="special">.</phrase><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase>       <phrase role="comment"># No crash, but still bad</phrase>
<phrase role="number">3.14</phrase>
</programlisting>
      <para>
        This is not really our intent of our C++ interface. We've broken our promise
        that the Python interface should reflect the C++ interface as closely as
        possible.
      </para>
      <para>
        Our problems do not end there. Suppose Y is implemented as follows:
      </para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">Y</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">X</phrase> <phrase role="identifier">x</phrase><phrase role="special">;</phrase> <phrase role="identifier">Z</phrase><phrase role="special">*</phrase> <phrase role="identifier">z</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">int</phrase> <phrase role="identifier">z_value</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">z</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">value</phrase><phrase role="special">();</phrase> <phrase role="special">}</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        Notice that the data member <literal>z</literal> is held by class Y using
        a raw pointer. Now we have a potential dangling pointer problem inside Y:
      </para>
<programlisting><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">y</phrase><phrase role="special">,</phrase> <phrase role="identifier">z</phrase><phrase role="special">)</phrase> <phrase role="special">#</phrase> <phrase role="identifier">y</phrase> <phrase role="identifier">refers</phrase> <phrase role="identifier">to</phrase> <phrase role="identifier">z</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">del</phrase> <phrase role="identifier">z</phrase>       <phrase role="special">#</phrase> <phrase role="identifier">Kill</phrase> <phrase role="identifier">the</phrase> <phrase role="identifier">z</phrase> <phrase role="identifier">object</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">y</phrase><phrase role="special">.</phrase><phrase role="identifier">z_value</phrase><phrase role="special">()</phrase> <phrase role="special">#</phrase> <phrase role="identifier">CRASH</phrase><phrase role="special">!</phrase>
</programlisting>
      <para>
        For reference, here's the implementation of <literal>f</literal> again:
      </para>
<programlisting><phrase role="identifier">X</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">Y</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">,</phrase> <phrase role="identifier">Z</phrase><phrase role="special">*</phrase> <phrase role="identifier">z</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">y</phrase><phrase role="special">.</phrase><phrase role="identifier">z</phrase> <phrase role="special">=</phrase> <phrase role="identifier">z</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">return</phrase> <phrase role="identifier">y</phrase><phrase role="special">.</phrase><phrase role="identifier">x</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        Here's what's happening:
      </para>
      <orderedlist>
        <listitem>
          <simpara>
            <literal>f</literal> is called passing in a reference to <literal>y</literal>
            and a pointer to <literal>z</literal>
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            A pointer to <literal>z</literal> is held by <literal>y</literal>
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            A reference to <literal>y.x</literal> is returned
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <literal>z</literal> is deleted. <literal>y.z</literal> is a dangling
            pointer
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <literal>y.z_value()</literal> is called
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <literal>z-&gt;value()</literal> is called
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <emphasis role="bold">BOOM!</emphasis>
          </simpara>
        </listitem>
      </orderedlist>
      <bridgehead renderas="sect2" id="tutorial.functions.call_policies.h0">
        <phrase id="tutorial.functions.call_policies.call_policies"/><link linkend="tutorial.functions.call_policies.call_policies">Call
        Policies</link>
      </bridgehead>
      <para>
        Call Policies may be used in situations such as the example detailed above.
        In our example, <literal>return_internal_reference</literal> and <literal>with_custodian_and_ward</literal>
        are our friends:
      </para>
<programlisting><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;f&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">f</phrase><phrase role="special">,</phrase>
    <phrase role="identifier">return_internal_reference</phrase><phrase role="special">&lt;</phrase><phrase role="number">1</phrase><phrase role="special">,</phrase>
        <phrase role="identifier">with_custodian_and_ward</phrase><phrase role="special">&lt;</phrase><phrase role="number">1</phrase><phrase role="special">,</phrase> <phrase role="number">2</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;());</phrase>
</programlisting>
      <para>
        What are the <literal>1</literal> and <literal>2</literal> parameters, you
        ask?
      </para>
<programlisting><phrase role="identifier">return_internal_reference</phrase><phrase role="special">&lt;</phrase><phrase role="number">1</phrase>
</programlisting>
      <para>
        Informs Boost.Python that the first argument, in our case <literal>Y&amp;
        y</literal>, is the owner of the returned reference: <literal>X&amp;</literal>.
        The &quot;<literal>1</literal>&quot; simply specifies the first argument.
        In short: &quot;return an internal reference <literal>X&amp;</literal> owned
        by the 1st argument <literal>Y&amp; y</literal>&quot;.
      </para>
<programlisting><phrase role="identifier">with_custodian_and_ward</phrase><phrase role="special">&lt;</phrase><phrase role="number">1</phrase><phrase role="special">,</phrase> <phrase role="number">2</phrase><phrase role="special">&gt;</phrase>
</programlisting>
      <para>
        Informs Boost.Python that the lifetime of the argument indicated by ward
        (i.e. the 2nd argument: <literal>Z* z</literal>) is dependent on the lifetime
        of the argument indicated by custodian (i.e. the 1st argument: <literal>Y&amp;
        y</literal>).
      </para>
      <para>
        It is also important to note that we have defined two policies above. Two
        or more policies can be composed by chaining. Here's the general syntax:
      </para>
<programlisting><phrase role="identifier">policy1</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">args</phrase><phrase role="special">...,</phrase>
    <phrase role="identifier">policy2</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">args</phrase><phrase role="special">...,</phrase>
        <phrase role="identifier">policy3</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">args</phrase><phrase role="special">...&gt;</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
</programlisting>
      <para>
        Here is the list of predefined call policies. A complete reference detailing
        these can be found <ulink url="../reference/function_invocation_and_creation/models_of_callpolicies.html">here</ulink>.
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            <emphasis role="bold">with_custodian_and_ward</emphasis>: Ties lifetimes
            of the arguments
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <emphasis role="bold">with_custodian_and_ward_postcall</emphasis>: Ties
            lifetimes of the arguments and results
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <emphasis role="bold">return_internal_reference</emphasis>: Ties lifetime
            of one argument to that of result
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <emphasis role="bold">return_value_policy&lt;T&gt; with T one of:</emphasis>
            <itemizedlist>
              <listitem>
                <simpara>
                  <emphasis role="bold">reference_existing_object</emphasis>: naive
                  (dangerous) approach
                </simpara>
              </listitem>
              <listitem>
                <simpara>
                  <emphasis role="bold">copy_const_reference</emphasis>: Boost.Python
                  v1 approach
                </simpara>
              </listitem>
              <listitem>
                <simpara>
                  <emphasis role="bold">copy_non_const_reference</emphasis>:
                </simpara>
              </listitem>
              <listitem>
                <simpara>
                  <emphasis role="bold">manage_new_object</emphasis>: Adopt a pointer
                  and hold the instance
                </simpara>
              </listitem>
            </itemizedlist>
          </simpara>
        </listitem>
      </itemizedlist>
      <sidebar role="blurb">
      <para>
        <inlinemediaobject><imageobject><imagedata fileref="../images/smiley.png"></imagedata></imageobject></inlinemediaobject>
        <emphasis role="bold">Remember the Zen, Luke:</emphasis>
      </para>
      <para>
        &quot;Explicit is better than implicit&quot;
      </para>
      <para>
        &quot;In the face of ambiguity, refuse the temptation to guess&quot;
      </para>
      </sidebar>
    </section>
    <section id="tutorial.functions.overloading">
      <title><link linkend="tutorial.functions.overloading">Overloading</link></title>
      <para>
        The following illustrates a scheme for manually wrapping an overloaded member
        functions. Of course, the same technique can be applied to wrapping overloaded
        non-member functions.
      </para>
      <para>
        We have here our C++ class:
      </para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">X</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">a</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
        <phrase role="keyword">return</phrase> <phrase role="keyword">true</phrase><phrase role="special">;</phrase>
    <phrase role="special">}</phrase>

    <phrase role="keyword">bool</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">a</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase> <phrase role="identifier">b</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
        <phrase role="keyword">return</phrase> <phrase role="keyword">true</phrase><phrase role="special">;</phrase>
    <phrase role="special">}</phrase>

    <phrase role="keyword">bool</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">a</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase> <phrase role="identifier">b</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase> <phrase role="identifier">c</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
        <phrase role="keyword">return</phrase> <phrase role="keyword">true</phrase><phrase role="special">;</phrase>
    <phrase role="special">}</phrase>

    <phrase role="keyword">int</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">a</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">b</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">c</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
        <phrase role="keyword">return</phrase> <phrase role="identifier">a</phrase> <phrase role="special">+</phrase> <phrase role="identifier">b</phrase> <phrase role="special">+</phrase> <phrase role="identifier">c</phrase><phrase role="special">;</phrase>
    <phrase role="special">};</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        Class X has 4 overloaded functions. We will start by introducing some member
        function pointer variables:
      </para>
<programlisting><phrase role="keyword">bool</phrase>    <phrase role="special">(</phrase><phrase role="identifier">X</phrase><phrase role="special">::*</phrase><phrase role="identifier">fx1</phrase><phrase role="special">)(</phrase><phrase role="keyword">int</phrase><phrase role="special">)</phrase>              <phrase role="special">=</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">;</phrase>
<phrase role="keyword">bool</phrase>    <phrase role="special">(</phrase><phrase role="identifier">X</phrase><phrase role="special">::*</phrase><phrase role="identifier">fx2</phrase><phrase role="special">)(</phrase><phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase><phrase role="special">)</phrase>      <phrase role="special">=</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">;</phrase>
<phrase role="keyword">bool</phrase>    <phrase role="special">(</phrase><phrase role="identifier">X</phrase><phrase role="special">::*</phrase><phrase role="identifier">fx3</phrase><phrase role="special">)(</phrase><phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase><phrase role="special">)=</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">;</phrase>
<phrase role="keyword">int</phrase>     <phrase role="special">(</phrase><phrase role="identifier">X</phrase><phrase role="special">::*</phrase><phrase role="identifier">fx4</phrase><phrase role="special">)(</phrase><phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase><phrase role="special">)</phrase>    <phrase role="special">=</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">;</phrase>
</programlisting>
      <para>
        With these in hand, we can proceed to define and wrap this for Python:
      </para>
<programlisting><phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;f&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">fx1</phrase><phrase role="special">)</phrase>
<phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;f&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">fx2</phrase><phrase role="special">)</phrase>
<phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;f&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">fx3</phrase><phrase role="special">)</phrase>
<phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;f&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">fx4</phrase><phrase role="special">)</phrase>
</programlisting>
    </section>
    <section id="tutorial.functions.default_arguments">
      <title><link linkend="tutorial.functions.default_arguments">Default Arguments</link></title>
      <para>
        Boost.Python wraps (member) function pointers. Unfortunately, C++ function
        pointers carry no default argument info. Take a function <literal>f</literal>
        with default arguments:
      </para>
<programlisting><phrase role="keyword">int</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase> <phrase role="special">=</phrase> <phrase role="number">3.14</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase> <phrase role="keyword">const</phrase><phrase role="special">*</phrase> <phrase role="special">=</phrase> <phrase role="string">&quot;hello&quot;</phrase><phrase role="special">);</phrase>
</programlisting>
      <para>
        But the type of a pointer to the function <literal>f</literal> has no information
        about its default arguments:
      </para>
<programlisting><phrase role="keyword">int</phrase><phrase role="special">(*</phrase><phrase role="identifier">g</phrase><phrase role="special">)(</phrase><phrase role="keyword">int</phrase><phrase role="special">,</phrase><phrase role="keyword">double</phrase><phrase role="special">,</phrase><phrase role="keyword">char</phrase> <phrase role="keyword">const</phrase><phrase role="special">*)</phrase> <phrase role="special">=</phrase> <phrase role="identifier">f</phrase><phrase role="special">;</phrase>    <phrase role="comment">// defaults lost!</phrase>
</programlisting>
      <para>
        When we pass this function pointer to the <literal>def</literal> function,
        there is no way to retrieve the default arguments:
      </para>
<programlisting><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;f&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">f</phrase><phrase role="special">);</phrase>                            <phrase role="comment">// defaults lost!</phrase>
</programlisting>
      <para>
        Because of this, when wrapping C++ code, we had to resort to manual wrapping
        as outlined in the <link linkend="tutorial.functions.overloading">previous
        section</link>, or writing thin wrappers:
      </para>
<programlisting><phrase role="comment">// write &quot;thin wrappers&quot;</phrase>
<phrase role="keyword">int</phrase> <phrase role="identifier">f1</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">);</phrase> <phrase role="special">}</phrase>
<phrase role="keyword">int</phrase> <phrase role="identifier">f2</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase> <phrase role="identifier">y</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">,</phrase><phrase role="identifier">y</phrase><phrase role="special">);</phrase> <phrase role="special">}</phrase>

<phrase role="comment">/*...*/</phrase>

    <phrase role="comment">// in module init</phrase>
    <phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;f&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">f</phrase><phrase role="special">);</phrase>  <phrase role="comment">// all arguments</phrase>
    <phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;f&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">f2</phrase><phrase role="special">);</phrase> <phrase role="comment">// two arguments</phrase>
    <phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;f&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">f1</phrase><phrase role="special">);</phrase> <phrase role="comment">// one argument</phrase>
</programlisting>
      <para>
        When you want to wrap functions (or member functions) that either:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            have default arguments, or
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            are overloaded with a common sequence of initial arguments
          </simpara>
        </listitem>
      </itemizedlist>
      <bridgehead renderas="sect2" id="tutorial.functions.default_arguments.h0">
        <phrase id="tutorial.functions.default_arguments.boost_python_function_overloads"/><link
        linkend="tutorial.functions.default_arguments.boost_python_function_overloads">BOOST_PYTHON_FUNCTION_OVERLOADS</link>
      </bridgehead>
      <para>
        Boost.Python now has a way to make it easier. For instance, given a function:
      </para>
<programlisting><phrase role="keyword">int</phrase> <phrase role="identifier">foo</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">a</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase> <phrase role="identifier">b</phrase> <phrase role="special">=</phrase> <phrase role="number">1</phrase><phrase role="special">,</phrase> <phrase role="keyword">unsigned</phrase> <phrase role="identifier">c</phrase> <phrase role="special">=</phrase> <phrase role="number">2</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase> <phrase role="identifier">d</phrase> <phrase role="special">=</phrase> <phrase role="number">3</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="comment">/*...*/</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        The macro invocation:
      </para>
<programlisting><phrase role="identifier">BOOST_PYTHON_FUNCTION_OVERLOADS</phrase><phrase role="special">(</phrase><phrase role="identifier">foo_overloads</phrase><phrase role="special">,</phrase> <phrase role="identifier">foo</phrase><phrase role="special">,</phrase> <phrase role="number">1</phrase><phrase role="special">,</phrase> <phrase role="number">4</phrase><phrase role="special">)</phrase>
</programlisting>
      <para>
        will automatically create the thin wrappers for us. This macro will create
        a class <literal>foo_overloads</literal> that can be passed on to <literal>def(...)</literal>.
        The third and fourth macro argument are the minimum arguments and maximum
        arguments, respectively. In our <literal>foo</literal> function the minimum
        number of arguments is 1 and the maximum number of arguments is 4. The <literal>def(...)</literal>
        function will automatically add all the foo variants for us:
      </para>
<programlisting><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;foo&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">foo</phrase><phrase role="special">,</phrase> <phrase role="identifier">foo_overloads</phrase><phrase role="special">());</phrase>
</programlisting>
      <bridgehead renderas="sect2" id="tutorial.functions.default_arguments.h1">
        <phrase id="tutorial.functions.default_arguments.boost_python_member_function_ove"/><link
        linkend="tutorial.functions.default_arguments.boost_python_member_function_ove">BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</link>
      </bridgehead>
      <para>
        Objects here, objects there, objects here there everywhere. More frequently
        than anything else, we need to expose member functions of our classes to
        Python. Then again, we have the same inconveniences as before when default
        arguments or overloads with a common sequence of initial arguments come into
        play. Another macro is provided to make this a breeze.
      </para>
      <para>
        Like <literal>BOOST_PYTHON_FUNCTION_OVERLOADS</literal>, <literal>BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</literal>
        may be used to automatically create the thin wrappers for wrapping member
        functions. Let's have an example:
      </para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">george</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">void</phrase>
    <phrase role="identifier">wack_em</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">a</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">b</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase> <phrase role="identifier">c</phrase> <phrase role="special">=</phrase> <phrase role="char">'x'</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
        <phrase role="comment">/*...*/</phrase>
    <phrase role="special">}</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        The macro invocation:
      </para>
<programlisting><phrase role="identifier">BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</phrase><phrase role="special">(</phrase><phrase role="identifier">george_overloads</phrase><phrase role="special">,</phrase> <phrase role="identifier">wack_em</phrase><phrase role="special">,</phrase> <phrase role="number">1</phrase><phrase role="special">,</phrase> <phrase role="number">3</phrase><phrase role="special">)</phrase>
</programlisting>
      <para>
        will generate a set of thin wrappers for george's <literal>wack_em</literal>
        member function accepting a minimum of 1 and a maximum of 3 arguments (i.e.
        the third and fourth macro argument). The thin wrappers are all enclosed
        in a class named <literal>george_overloads</literal> that can then be used
        as an argument to <literal>def(...)</literal>:
      </para>
<programlisting><phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;wack_em&quot;</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">george</phrase><phrase role="special">::</phrase><phrase role="identifier">wack_em</phrase><phrase role="special">,</phrase> <phrase role="identifier">george_overloads</phrase><phrase role="special">());</phrase>
</programlisting>
      <para>
        See the <ulink url="../reference/function_invocation_and_creation/boost_python_overloads_hpp.html#function_invocation_and_creation.boost_python_overloads_hpp.macros">overloads
        reference</ulink> for details.
      </para>
      <bridgehead renderas="sect2" id="tutorial.functions.default_arguments.h2">
        <phrase id="tutorial.functions.default_arguments.init_and_optional"/><link
        linkend="tutorial.functions.default_arguments.init_and_optional">init and
        optional</link>
      </bridgehead>
      <para>
        A similar facility is provided for class constructors, again, with default
        arguments or a sequence of overloads. Remember <literal>init&lt;...&gt;</literal>?
        For example, given a class X with a constructor:
      </para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">X</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">X</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">a</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase> <phrase role="identifier">b</phrase> <phrase role="special">=</phrase> <phrase role="char">'D'</phrase><phrase role="special">,</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">c</phrase> <phrase role="special">=</phrase> <phrase role="string">&quot;constructor&quot;</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase> <phrase role="identifier">d</phrase> <phrase role="special">=</phrase> <phrase role="number">0.0</phrase><phrase role="special">);</phrase>
    <phrase role="comment">/*...*/</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        You can easily add this constructor to Boost.Python in one shot:
      </para>
<programlisting><phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">init</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="identifier">optional</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">char</phrase><phrase role="special">,</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;())</phrase>
</programlisting>
      <para>
        Notice the use of <literal>init&lt;...&gt;</literal> and <literal>optional&lt;...&gt;</literal>
        to signify the default (optional arguments).
      </para>
    </section>
    <section id="tutorial.functions.auto_overloading">
      <title><link linkend="tutorial.functions.auto_overloading">Auto-Overloading</link></title>
      <para>
        It was mentioned in passing in the previous section that <literal>BOOST_PYTHON_FUNCTION_OVERLOADS</literal>
        and <literal>BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</literal> can also be
        used for overloaded functions and member functions with a common sequence
        of initial arguments. Here is an example:
      </para>
<programlisting><phrase role="keyword">void</phrase> <phrase role="identifier">foo</phrase><phrase role="special">()</phrase>
<phrase role="special">{</phrase>
   <phrase role="comment">/*...*/</phrase>
<phrase role="special">}</phrase>

<phrase role="keyword">void</phrase> <phrase role="identifier">foo</phrase><phrase role="special">(</phrase><phrase role="keyword">bool</phrase> <phrase role="identifier">a</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
   <phrase role="comment">/*...*/</phrase>
<phrase role="special">}</phrase>

<phrase role="keyword">void</phrase> <phrase role="identifier">foo</phrase><phrase role="special">(</phrase><phrase role="keyword">bool</phrase> <phrase role="identifier">a</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">b</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
   <phrase role="comment">/*...*/</phrase>
<phrase role="special">}</phrase>

<phrase role="keyword">void</phrase> <phrase role="identifier">foo</phrase><phrase role="special">(</phrase><phrase role="keyword">bool</phrase> <phrase role="identifier">a</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">b</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase> <phrase role="identifier">c</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
   <phrase role="comment">/*...*/</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        Like in the previous section, we can generate thin wrappers for these overloaded
        functions in one-shot:
      </para>
<programlisting><phrase role="identifier">BOOST_PYTHON_FUNCTION_OVERLOADS</phrase><phrase role="special">(</phrase><phrase role="identifier">foo_overloads</phrase><phrase role="special">,</phrase> <phrase role="identifier">foo</phrase><phrase role="special">,</phrase> <phrase role="number">0</phrase><phrase role="special">,</phrase> <phrase role="number">3</phrase><phrase role="special">)</phrase>
</programlisting>
      <para>
        Then...
      </para>
<programlisting><phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;foo&quot;</phrase><phrase role="special">,</phrase> <phrase role="special">(</phrase><phrase role="keyword">void</phrase><phrase role="special">(*)(</phrase><phrase role="keyword">bool</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase><phrase role="special">))</phrase><phrase role="number">0</phrase><phrase role="special">,</phrase> <phrase role="identifier">foo_overloads</phrase><phrase role="special">());</phrase>
</programlisting>
      <para>
        Notice though that we have a situation now where we have a minimum of zero
        (0) arguments and a maximum of 3 arguments.
      </para>
      <bridgehead renderas="sect2" id="tutorial.functions.auto_overloading.h0">
        <phrase id="tutorial.functions.auto_overloading.manual_wrapping"/><link linkend="tutorial.functions.auto_overloading.manual_wrapping">Manual
        Wrapping</link>
      </bridgehead>
      <para>
        It is important to emphasize however that <emphasis role="bold">the overloaded
        functions must have a common sequence of initial arguments</emphasis>. Otherwise,
        our scheme above will not work. If this is not the case, we have to wrap
        our functions <link linkend="tutorial.functions.overloading">manually</link>.
      </para>
      <para>
        Actually, we can mix and match manual wrapping of overloaded functions and
        automatic wrapping through <literal>BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</literal>
        and its sister, <literal>BOOST_PYTHON_FUNCTION_OVERLOADS</literal>. Following
        up on our example presented in the section <link linkend="tutorial.functions.overloading">on
        overloading</link>, since the first 4 overload functins have a common sequence
        of initial arguments, we can use <literal>BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</literal>
        to automatically wrap the first three of the <literal>def</literal>s and
        manually wrap just the last. Here's how we'll do this:
      </para>
<programlisting><phrase role="identifier">BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</phrase><phrase role="special">(</phrase><phrase role="identifier">xf_overloads</phrase><phrase role="special">,</phrase> <phrase role="identifier">f</phrase><phrase role="special">,</phrase> <phrase role="number">1</phrase><phrase role="special">,</phrase> <phrase role="number">4</phrase><phrase role="special">)</phrase>
</programlisting>
      <para>
        Create a member function pointers as above for both X::f overloads:
      </para>
<programlisting><phrase role="keyword">bool</phrase>    <phrase role="special">(</phrase><phrase role="identifier">X</phrase><phrase role="special">::*</phrase><phrase role="identifier">fx1</phrase><phrase role="special">)(</phrase><phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase><phrase role="special">)</phrase>    <phrase role="special">=</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">;</phrase>
<phrase role="keyword">int</phrase>     <phrase role="special">(</phrase><phrase role="identifier">X</phrase><phrase role="special">::*</phrase><phrase role="identifier">fx2</phrase><phrase role="special">)(</phrase><phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase><phrase role="special">)</phrase>        <phrase role="special">=</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">;</phrase>
</programlisting>
      <para>
        Then...
      </para>
<programlisting><phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;f&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">fx1</phrase><phrase role="special">,</phrase> <phrase role="identifier">xf_overloads</phrase><phrase role="special">());</phrase>
<phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;f&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">fx2</phrase><phrase role="special">)</phrase>
</programlisting>
    </section>
  </section>
  <section id="tutorial.object">
    <title><link linkend="tutorial.object">Object Interface</link></title>
    <para>
      Python is dynamically typed, unlike C++ which is statically typed. Python variables
      may hold an integer, a float, list, dict, tuple, str, long etc., among other
      things. In the viewpoint of Boost.Python and C++, these Pythonic variables
      are just instances of class <literal>object</literal>. We will see in this
      chapter how to deal with Python objects.
    </para>
    <para>
      As mentioned, one of the goals of Boost.Python is to provide a bidirectional
      mapping between C++ and Python while maintaining the Python feel. Boost.Python
      C++ <literal>object</literal>s are as close as possible to Python. This should
      minimize the learning curve significantly.
    </para>
    <para>
      <inlinemediaobject><imageobject><imagedata fileref="../images/python.png"></imagedata></imageobject></inlinemediaobject>
    </para>
    <section id="tutorial.object.basic_interface">
      <title><link linkend="tutorial.object.basic_interface">Basic Interface</link></title>
      <para>
        Class <literal>object</literal> wraps <literal>PyObject*</literal>. All the
        intricacies of dealing with <literal>PyObject</literal>s such as managing
        reference counting are handled by the <literal>object</literal> class. C++
        object interoperability is seamless. Boost.Python C++ <literal>object</literal>s
        can in fact be explicitly constructed from any C++ object.
      </para>
      <para>
        To illustrate, this Python code snippet:
      </para>
<programlisting><phrase role="keyword">def</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">y</phrase><phrase role="special">):</phrase>
     <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="identifier">y</phrase> <phrase role="special">==</phrase> <phrase role="string">'foo'</phrase><phrase role="special">):</phrase>
         <phrase role="identifier">x</phrase><phrase role="special">[</phrase><phrase role="number">3</phrase><phrase role="special">:</phrase><phrase role="number">7</phrase><phrase role="special">]</phrase> <phrase role="special">=</phrase> <phrase role="string">'bar'</phrase>
     <phrase role="keyword">else</phrase><phrase role="special">:</phrase>
         <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">items</phrase> <phrase role="special">+=</phrase> <phrase role="identifier">y</phrase><phrase role="special">(</phrase><phrase role="number">3</phrase><phrase role="special">,</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase>
     <phrase role="keyword">return</phrase> <phrase role="identifier">x</phrase>

<phrase role="keyword">def</phrase> <phrase role="identifier">getfunc</phrase><phrase role="special">():</phrase>
   <phrase role="keyword">return</phrase> <phrase role="identifier">f</phrase><phrase role="special">;</phrase>
</programlisting>
      <para>
        Can be rewritten in C++ using Boost.Python facilities this way:
      </para>
<programlisting><phrase role="identifier">object</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">object</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">object</phrase> <phrase role="identifier">y</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase>
     <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="identifier">y</phrase> <phrase role="special">==</phrase> <phrase role="string">&quot;foo&quot;</phrase><phrase role="special">)</phrase>
         <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">slice</phrase><phrase role="special">(</phrase><phrase role="number">3</phrase><phrase role="special">,</phrase><phrase role="number">7</phrase><phrase role="special">)</phrase> <phrase role="special">=</phrase> <phrase role="string">&quot;bar&quot;</phrase><phrase role="special">;</phrase>
     <phrase role="keyword">else</phrase>
         <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">attr</phrase><phrase role="special">(</phrase><phrase role="string">&quot;items&quot;</phrase><phrase role="special">)</phrase> <phrase role="special">+=</phrase> <phrase role="identifier">y</phrase><phrase role="special">(</phrase><phrase role="number">3</phrase><phrase role="special">,</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
     <phrase role="keyword">return</phrase> <phrase role="identifier">x</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
<phrase role="identifier">object</phrase> <phrase role="identifier">getfunc</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase>
    <phrase role="keyword">return</phrase> <phrase role="identifier">object</phrase><phrase role="special">(</phrase><phrase role="identifier">f</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        Apart from cosmetic differences due to the fact that we are writing the code
        in C++, the look and feel should be immediately apparent to the Python coder.
      </para>
    </section>
    <section id="tutorial.object.derived_object_types">
      <title><link linkend="tutorial.object.derived_object_types">Derived Object
      types</link></title>
      <para>
        Boost.Python comes with a set of derived <literal>object</literal> types
        corresponding to that of Python's:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            list
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            dict
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            tuple
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            str
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            long_
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            enum
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        These derived <literal>object</literal> types act like real Python types.
        For instance:
      </para>
<programlisting><phrase role="identifier">str</phrase><phrase role="special">(</phrase><phrase role="number">1</phrase><phrase role="special">)</phrase> <phrase role="special">==&gt;</phrase> <phrase role="string">&quot;1&quot;</phrase>
</programlisting>
      <para>
        Wherever appropriate, a particular derived <literal>object</literal> has
        corresponding Python type's methods. For instance, <literal>dict</literal>
        has a <literal>keys()</literal> method:
      </para>
<programlisting><phrase role="identifier">d</phrase><phrase role="special">.</phrase><phrase role="identifier">keys</phrase><phrase role="special">()</phrase>
</programlisting>
      <para>
        <literal>make_tuple</literal> is provided for declaring <emphasis>tuple literals</emphasis>.
        Example:
      </para>
<programlisting><phrase role="identifier">make_tuple</phrase><phrase role="special">(</phrase><phrase role="number">123</phrase><phrase role="special">,</phrase> <phrase role="char">'D'</phrase><phrase role="special">,</phrase> <phrase role="string">&quot;Hello, World&quot;</phrase><phrase role="special">,</phrase> <phrase role="number">0.0</phrase><phrase role="special">);</phrase>
</programlisting>
      <para>
        In C++, when Boost.Python <literal>object</literal>s are used as arguments
        to functions, subtype matching is required. For example, when a function
        <literal>f</literal>, as declared below, is wrapped, it will only accept
        instances of Python's <literal>str</literal> type and subtypes.
      </para>
<programlisting><phrase role="keyword">void</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">str</phrase> <phrase role="identifier">name</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">object</phrase> <phrase role="identifier">n2</phrase> <phrase role="special">=</phrase> <phrase role="identifier">name</phrase><phrase role="special">.</phrase><phrase role="identifier">attr</phrase><phrase role="special">(</phrase><phrase role="string">&quot;upper&quot;</phrase><phrase role="special">)();</phrase>   <phrase role="comment">// NAME = name.upper()</phrase>
    <phrase role="identifier">str</phrase> <phrase role="identifier">NAME</phrase> <phrase role="special">=</phrase> <phrase role="identifier">name</phrase><phrase role="special">.</phrase><phrase role="identifier">upper</phrase><phrase role="special">();</phrase>            <phrase role="comment">// better</phrase>
    <phrase role="identifier">object</phrase> <phrase role="identifier">msg</phrase> <phrase role="special">=</phrase> <phrase role="string">&quot;%s is bigger than %s&quot;</phrase> <phrase role="special">%</phrase> <phrase role="identifier">make_tuple</phrase><phrase role="special">(</phrase><phrase role="identifier">NAME</phrase><phrase role="special">,</phrase><phrase role="identifier">name</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        In finer detail:
      </para>
<programlisting><phrase role="identifier">str</phrase> <phrase role="identifier">NAME</phrase> <phrase role="special">=</phrase> <phrase role="identifier">name</phrase><phrase role="special">.</phrase><phrase role="identifier">upper</phrase><phrase role="special">();</phrase>
</programlisting>
      <para>
        Illustrates that we provide versions of the str type's methods as C++ member
        functions.
      </para>
<programlisting><phrase role="identifier">object</phrase> <phrase role="identifier">msg</phrase> <phrase role="special">=</phrase> <phrase role="string">&quot;%s is bigger than %s&quot;</phrase> <phrase role="special">%</phrase> <phrase role="identifier">make_tuple</phrase><phrase role="special">(</phrase><phrase role="identifier">NAME</phrase><phrase role="special">,</phrase><phrase role="identifier">name</phrase><phrase role="special">);</phrase>
</programlisting>
      <para>
        Demonstrates that you can write the C++ equivalent of <literal>&quot;format&quot;
        % x,y,z</literal> in Python, which is useful since there's no easy way to
        do that in std C++.
      </para>
      <sidebar role="blurb">
      <para>
        <inlinemediaobject><imageobject><imagedata fileref="../images/alert.png"></imagedata></imageobject></inlinemediaobject>
        <emphasis role="bold">Beware</emphasis> the common pitfall of forgetting
        that the constructors of most of Python's mutable types make copies, just
        as in Python.
      </para>
      </sidebar>
      <para>
        Python:
      </para>
<programlisting><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">d</phrase> <phrase role="special">=</phrase> <phrase role="identifier">dict</phrase><phrase role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">__dict__</phrase><phrase role="special">)</phrase>     <phrase role="comment"># copies x.__dict__</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">d</phrase><phrase role="special">[</phrase><phrase role="string">'whatever'</phrase><phrase role="special">]</phrase> <phrase role="special">=</phrase> <phrase role="number">3</phrase>        <phrase role="comment"># modifies the copy</phrase>
</programlisting>
      <para>
        C++:
      </para>
<programlisting><phrase role="identifier">dict</phrase> <phrase role="identifier">d</phrase><phrase role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">attr</phrase><phrase role="special">(</phrase><phrase role="string">&quot;__dict__&quot;</phrase><phrase role="special">));</phrase>  <phrase role="comment">// copies x.__dict__</phrase>
<phrase role="identifier">d</phrase><phrase role="special">[</phrase><phrase role="char">'whatever'</phrase><phrase role="special">]</phrase> <phrase role="special">=</phrase> <phrase role="number">3</phrase><phrase role="special">;</phrase>           <phrase role="comment">// modifies the copy</phrase>
</programlisting>
      <bridgehead renderas="sect2" id="tutorial.object.derived_object_types.h0">
        <phrase id="tutorial.object.derived_object_types.class_t_as_objects"/><link
        linkend="tutorial.object.derived_object_types.class_t_as_objects">class_&lt;T&gt;
        as objects</link>
      </bridgehead>
      <para>
        Due to the dynamic nature of Boost.Python objects, any <literal>class_&lt;T&gt;</literal>
        may also be one of these types! The following code snippet wraps the class
        (type) object.
      </para>
      <para>
        We can use this to create wrapped instances. Example:
      </para>
<programlisting><phrase role="identifier">object</phrase> <phrase role="identifier">vec345</phrase> <phrase role="special">=</phrase> <phrase role="special">(</phrase>
    <phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Vec2</phrase><phrase role="special">&gt;(</phrase><phrase role="string">&quot;Vec2&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">init</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">double</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase><phrase role="special">&gt;())</phrase>
        <phrase role="special">.</phrase><phrase role="identifier">def_readonly</phrase><phrase role="special">(</phrase><phrase role="string">&quot;length&quot;</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">Point</phrase><phrase role="special">::</phrase><phrase role="identifier">length</phrase><phrase role="special">)</phrase>
        <phrase role="special">.</phrase><phrase role="identifier">def_readonly</phrase><phrase role="special">(</phrase><phrase role="string">&quot;angle&quot;</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">Point</phrase><phrase role="special">::</phrase><phrase role="identifier">angle</phrase><phrase role="special">)</phrase>
    <phrase role="special">)(</phrase><phrase role="number">3.0</phrase><phrase role="special">,</phrase> <phrase role="number">4.0</phrase><phrase role="special">);</phrase>

<phrase role="identifier">assert</phrase><phrase role="special">(</phrase><phrase role="identifier">vec345</phrase><phrase role="special">.</phrase><phrase role="identifier">attr</phrase><phrase role="special">(</phrase><phrase role="string">&quot;length&quot;</phrase><phrase role="special">)</phrase> <phrase role="special">==</phrase> <phrase role="number">5.0</phrase><phrase role="special">);</phrase>
</programlisting>
    </section>
    <section id="tutorial.object.extracting_c_objects">
      <title><link linkend="tutorial.object.extracting_c_objects">Extracting C++
      objects</link></title>
      <para>
        At some point, we will need to get C++ values out of object instances. This
        can be achieved with the <literal>extract&lt;T&gt;</literal> function. Consider
        the following:
      </para>
<programlisting><phrase role="keyword">double</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">o</phrase><phrase role="special">.</phrase><phrase role="identifier">attr</phrase><phrase role="special">(</phrase><phrase role="string">&quot;length&quot;</phrase><phrase role="special">);</phrase> <phrase role="comment">// compile error</phrase>
</programlisting>
      <para>
        In the code above, we got a compiler error because Boost.Python <literal>object</literal>
        can't be implicitly converted to <literal>double</literal>s. Instead, what
        we wanted to do above can be achieved by writing:
      </para>
<programlisting><phrase role="keyword">double</phrase> <phrase role="identifier">l</phrase> <phrase role="special">=</phrase> <phrase role="identifier">extract</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">double</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">o</phrase><phrase role="special">.</phrase><phrase role="identifier">attr</phrase><phrase role="special">(</phrase><phrase role="string">&quot;length&quot;</phrase><phrase role="special">));</phrase>
<phrase role="identifier">Vec2</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">v</phrase> <phrase role="special">=</phrase> <phrase role="identifier">extract</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Vec2</phrase><phrase role="special">&amp;&gt;(</phrase><phrase role="identifier">o</phrase><phrase role="special">);</phrase>
<phrase role="identifier">assert</phrase><phrase role="special">(</phrase><phrase role="identifier">l</phrase> <phrase role="special">==</phrase> <phrase role="identifier">v</phrase><phrase role="special">.</phrase><phrase role="identifier">length</phrase><phrase role="special">());</phrase>
</programlisting>
      <para>
        The first line attempts to extract the &quot;length&quot; attribute of the
        Boost.Python <literal>object</literal>. The second line attempts to <emphasis>extract</emphasis>
        the <literal>Vec2</literal> object from held by the Boost.Python <literal>object</literal>.
      </para>
      <para>
        Take note that we said &quot;attempt to&quot; above. What if the Boost.Python
        <literal>object</literal> does not really hold a <literal>Vec2</literal>
        type? This is certainly a possibility considering the dynamic nature of Python
        <literal>object</literal>s. To be on the safe side, if the C++ type can't
        be extracted, an appropriate exception is thrown. To avoid an exception,
        we need to test for extractibility:
      </para>
<programlisting><phrase role="identifier">extract</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Vec2</phrase><phrase role="special">&amp;&gt;</phrase> <phrase role="identifier">x</phrase><phrase role="special">(</phrase><phrase role="identifier">o</phrase><phrase role="special">);</phrase>
<phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">check</phrase><phrase role="special">())</phrase> <phrase role="special">{</phrase>
    <phrase role="identifier">Vec2</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">v</phrase> <phrase role="special">=</phrase> <phrase role="identifier">x</phrase><phrase role="special">();</phrase> <phrase role="special">...</phrase>
</programlisting>
      <para>
        <inlinemediaobject><imageobject><imagedata fileref="../images/tip.png"></imagedata></imageobject></inlinemediaobject>
        The astute reader might have noticed that the <literal>extract&lt;T&gt;</literal>
        facility in fact solves the mutable copying problem:
      </para>
<programlisting><phrase role="identifier">dict</phrase> <phrase role="identifier">d</phrase> <phrase role="special">=</phrase> <phrase role="identifier">extract</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">dict</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">attr</phrase><phrase role="special">(</phrase><phrase role="string">&quot;__dict__&quot;</phrase><phrase role="special">));</phrase>
<phrase role="identifier">d</phrase><phrase role="special">[</phrase><phrase role="string">&quot;whatever&quot;</phrase><phrase role="special">]</phrase> <phrase role="special">=</phrase> <phrase role="number">3</phrase><phrase role="special">;</phrase>          <phrase role="comment">// modifies x.__dict__ !</phrase>
</programlisting>
    </section>
    <section id="tutorial.object.enums">
      <title><link linkend="tutorial.object.enums">Enums</link></title>
      <para>
        Boost.Python has a nifty facility to capture and wrap C++ enums. While Python
        has no <literal>enum</literal> type, we'll often want to expose our C++ enums
        to Python as an <literal>int</literal>. Boost.Python's enum facility makes
        this easy while taking care of the proper conversions from Python's dynamic
        typing to C++'s strong static typing (in C++, ints cannot be implicitly converted
        to enums). To illustrate, given a C++ enum:
      </para>
<programlisting><phrase role="keyword">enum</phrase> <phrase role="identifier">choice</phrase> <phrase role="special">{</phrase> <phrase role="identifier">red</phrase><phrase role="special">,</phrase> <phrase role="identifier">blue</phrase> <phrase role="special">};</phrase>
</programlisting>
      <para>
        the construct:
      </para>
<programlisting><phrase role="identifier">enum_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">choice</phrase><phrase role="special">&gt;(</phrase><phrase role="string">&quot;choice&quot;</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">value</phrase><phrase role="special">(</phrase><phrase role="string">&quot;red&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">red</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">value</phrase><phrase role="special">(</phrase><phrase role="string">&quot;blue&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">blue</phrase><phrase role="special">)</phrase>
    <phrase role="special">;</phrase>
</programlisting>
      <para>
        can be used to expose to Python. The new enum type is created in the current
        <literal>scope()</literal>, which is usually the current module. The snippet
        above creates a Python class derived from Python's <literal>int</literal>
        type which is associated with the C++ type passed as its first parameter.
      </para>
      <note>
        <para>
          <emphasis role="bold">what is a scope?</emphasis>
        </para>
        <para>
          The scope is a class that has an associated global Python object which
          controls the Python namespace in which new extension classes and wrapped
          functions will be defined as attributes. Details can be found <ulink url="../reference/high_level_components/boost_python_scope_hpp.html#high_level_components.boost_python_scope_hpp.class_scope">here</ulink>.
        </para>
      </note>
      <para>
        You can access those values in Python as
      </para>
<programlisting><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">my_module</phrase><phrase role="special">.</phrase><phrase role="identifier">choice</phrase><phrase role="special">.</phrase><phrase role="identifier">red</phrase>
<phrase role="identifier">my_module</phrase><phrase role="special">.</phrase><phrase role="identifier">choice</phrase><phrase role="special">.</phrase><phrase role="identifier">red</phrase>
</programlisting>
      <para>
        where my_module is the module where the enum is declared. You can also create
        a new scope around a class:
      </para>
<programlisting><phrase role="identifier">scope</phrase> <phrase role="identifier">in_X</phrase> <phrase role="special">=</phrase> <phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">X</phrase><phrase role="special">&gt;(</phrase><phrase role="string">&quot;X&quot;</phrase><phrase role="special">)</phrase>
                <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase> <phrase role="special">...</phrase> <phrase role="special">)</phrase>
                <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase> <phrase role="special">...</phrase> <phrase role="special">)</phrase>
            <phrase role="special">;</phrase>

<phrase role="comment">// Expose X::nested as X.nested</phrase>
<phrase role="identifier">enum_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">nested</phrase><phrase role="special">&gt;(</phrase><phrase role="string">&quot;nested&quot;</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">value</phrase><phrase role="special">(</phrase><phrase role="string">&quot;red&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">red</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">value</phrase><phrase role="special">(</phrase><phrase role="string">&quot;blue&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">blue</phrase><phrase role="special">)</phrase>
    <phrase role="special">;</phrase>
</programlisting>
    </section>
    <section id="tutorial.object.creating_python_object">
      <title><link linkend="tutorial.object.creating_python_object">Creating <code><phrase
      role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">python</phrase><phrase
      role="special">::</phrase><phrase role="identifier">object</phrase></code>
      from <code><phrase role="identifier">PyObject</phrase><phrase role="special">*</phrase></code></link></title>
      <para>
        When you want a <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase
        role="identifier">python</phrase><phrase role="special">::</phrase><phrase
        role="identifier">object</phrase></code> to manage a pointer to <code><phrase
        role="identifier">PyObject</phrase><phrase role="special">*</phrase></code>
        pyobj one does:
      </para>
<programlisting><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">python</phrase><phrase role="special">::</phrase><phrase role="identifier">object</phrase> <phrase role="identifier">o</phrase><phrase role="special">(</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">python</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;&gt;(</phrase><phrase role="identifier">pyobj</phrase><phrase role="special">));</phrase>
</programlisting>
      <para>
        In this case, the <code><phrase role="identifier">o</phrase></code> object,
        manages the <code><phrase role="identifier">pyobj</phrase></code>, it won’t
        increase the reference count on construction.
      </para>
      <para>
        Otherwise, to use a borrowed reference:
      </para>
<programlisting><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">python</phrase><phrase role="special">::</phrase><phrase role="identifier">object</phrase> <phrase role="identifier">o</phrase><phrase role="special">(</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">python</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;&gt;(</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">python</phrase><phrase role="special">::</phrase><phrase role="identifier">borrowed</phrase><phrase role="special">(</phrase><phrase role="identifier">pyobj</phrase><phrase role="special">)));</phrase>
</programlisting>
      <para>
        In this case, <code><phrase role="identifier">Py_INCREF</phrase></code> is
        called, so <code><phrase role="identifier">pyobj</phrase></code> is not destructed
        when object o goes out of scope.
      </para>
    </section>
  </section>
  <section id="tutorial.embedding">
    <title><link linkend="tutorial.embedding">Embedding</link></title>
    <para>
      By now you should know how to use Boost.Python to call your C++ code from Python.
      However, sometimes you may need to do the reverse: call Python code from the
      C++-side. This requires you to <emphasis>embed</emphasis> the Python interpreter
      into your C++ program.
    </para>
    <para>
      Currently, Boost.Python does not directly support everything you'll need when
      embedding. Therefore you'll need to use the <ulink url="http://www.python.org/doc/current/api/api.html">Python/C
      API</ulink> to fill in the gaps. However, Boost.Python already makes embedding
      a lot easier and, in a future version, it may become unnecessary to touch the
      Python/C API at all. So stay tuned... <inlinemediaobject><imageobject><imagedata
      fileref="../images/smiley.png"></imagedata></imageobject></inlinemediaobject>
    </para>
    <bridgehead renderas="sect2" id="tutorial.embedding.h0">
      <phrase id="tutorial.embedding.building_embedded_programs"/><link linkend="tutorial.embedding.building_embedded_programs">Building
      embedded programs</link>
    </bridgehead>
    <para>
      To be able to embed python into your programs, you have to link to both Boost.Python's
      as well as Python's own runtime library.
    </para>
    <para>
      Boost.Python's library comes in two variants. Both are located in Boost's
      <literal>/libs/python/build/bin-stage</literal> subdirectory. On Windows, the
      variants are called <literal>boost_python.lib</literal> (for release builds)
      and <literal>boost_python_debug.lib</literal> (for debugging). If you can't
      find the libraries, you probably haven't built Boost.Python yet. See <ulink
      url="../../../building.html">Building and Testing</ulink> on how to do this.
    </para>
    <para>
      Python's library can be found in the <literal>/libs</literal> subdirectory
      of your Python directory. On Windows it is called pythonXY.lib where X.Y is
      your major Python version number.
    </para>
    <para>
      Additionally, Python's <literal>/include</literal> subdirectory has to be added
      to your include path.
    </para>
    <para>
      In a Jamfile, all the above boils down to:
    </para>
<programlisting>projectroot c:\projects\embedded_program ; # location of the program

# bring in the rules for python
SEARCH on python.jam = $(BOOST_BUILD_PATH) ;
include python.jam ;

exe embedded_program # name of the executable
  : #sources
     embedded_program.cpp
  : # requirements
     &lt;find-library&gt;boost_python &lt;library-path&gt;c:\boost\libs\python
  $(PYTHON_PROPERTIES)
    &lt;library-path&gt;$(PYTHON_LIB_PATH)
    &lt;find-library&gt;$(PYTHON_EMBEDDED_LIBRARY) ;
</programlisting>
    <bridgehead renderas="sect2" id="tutorial.embedding.h1">
      <phrase id="tutorial.embedding.getting_started"/><link linkend="tutorial.embedding.getting_started">Getting
      started</link>
    </bridgehead>
    <para>
      Being able to build is nice, but there is nothing to build yet. Embedding the
      Python interpreter into one of your C++ programs requires these 4 steps:
    </para>
    <orderedlist>
      <listitem>
        <simpara>
          #include <literal>&lt;boost/python.hpp&gt;</literal>
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          Call <ulink url="http://www.python.org/doc/current/api/initialization.html#l2h-652">Py_Initialize</ulink>()
          to start the interpreter and create the <literal>__main__</literal> module.
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          Call other Python C API routines to use the interpreter.
        </simpara>
      </listitem>
    </orderedlist>
    <note>
      <para>
        <emphasis role="bold">Note that at this time you must not call <ulink url="http://www.python.org/doc/current/api/initialization.html#l2h-656">Py_Finalize</ulink>()
        to stop the interpreter. This may be fixed in a future version of boost.python.</emphasis>
      </para>
    </note>
    <para>
      (Of course, there can be other C++ code between all of these steps.)
    </para>
    <blockquote>
      <para>
        <emphasis><emphasis role="bold">Now that we can embed the interpreter in
        our programs, lets see how to put it to use...</emphasis></emphasis>
      </para>
    </blockquote>
    <section id="tutorial.embedding.using_the_interpreter">
      <title><link linkend="tutorial.embedding.using_the_interpreter">Using the interpreter</link></title>
      <para>
        As you probably already know, objects in Python are reference-counted. Naturally,
        the <literal>PyObject</literal>s of the Python C API are also reference-counted.
        There is a difference however. While the reference-counting is fully automatic
        in Python, the Python C API requires you to do it <ulink url="http://www.python.org/doc/current/c-api/refcounting.html">by
        hand</ulink>. This is messy and especially hard to get right in the presence
        of C++ exceptions. Fortunately Boost.Python provides the <ulink url="../reference/utility_and_infrastructure/boost_python_handle_hpp.html#utility_and_infrastructure.boost_python_handle_hpp.class_template_handle">handle</ulink>
        and <ulink url="../reference/object_wrappers/boost_python_object_hpp.html#object_wrappers.boost_python_object_hpp.class_object">object</ulink>
        class templates to automate the process.
      </para>
      <bridgehead renderas="sect2" id="tutorial.embedding.using_the_interpreter.h0">
        <phrase id="tutorial.embedding.using_the_interpreter.running_python_code"/><link
        linkend="tutorial.embedding.using_the_interpreter.running_python_code">Running
        Python code</link>
      </bridgehead>
      <para>
        Boost.python provides three related functions to run Python code from C++.
      </para>
<programlisting><phrase role="identifier">object</phrase> <phrase role="identifier">eval</phrase><phrase role="special">(</phrase><phrase role="identifier">str</phrase> <phrase role="identifier">expression</phrase><phrase role="special">,</phrase> <phrase role="identifier">object</phrase> <phrase role="identifier">globals</phrase> <phrase role="special">=</phrase> <phrase role="identifier">object</phrase><phrase role="special">(),</phrase> <phrase role="identifier">object</phrase> <phrase role="identifier">locals</phrase> <phrase role="special">=</phrase> <phrase role="identifier">object</phrase><phrase role="special">())</phrase>
<phrase role="identifier">object</phrase> <phrase role="identifier">exec</phrase><phrase role="special">(</phrase><phrase role="identifier">str</phrase> <phrase role="identifier">code</phrase><phrase role="special">,</phrase> <phrase role="identifier">object</phrase> <phrase role="identifier">globals</phrase> <phrase role="special">=</phrase> <phrase role="identifier">object</phrase><phrase role="special">(),</phrase> <phrase role="identifier">object</phrase> <phrase role="identifier">locals</phrase> <phrase role="special">=</phrase> <phrase role="identifier">object</phrase><phrase role="special">())</phrase>
<phrase role="identifier">object</phrase> <phrase role="identifier">exec_file</phrase><phrase role="special">(</phrase><phrase role="identifier">str</phrase> <phrase role="identifier">filename</phrase><phrase role="special">,</phrase> <phrase role="identifier">object</phrase> <phrase role="identifier">globals</phrase> <phrase role="special">=</phrase> <phrase role="identifier">object</phrase><phrase role="special">(),</phrase> <phrase role="identifier">object</phrase> <phrase role="identifier">locals</phrase> <phrase role="special">=</phrase> <phrase role="identifier">object</phrase><phrase role="special">())</phrase>
</programlisting>
      <para>
        eval evaluates the given expression and returns the resulting value. exec
        executes the given code (typically a set of statements) returning the result,
        and exec_file executes the code contained in the given file.
      </para>
      <para>
        The <literal>globals</literal> and <literal>locals</literal> parameters are
        Python dictionaries containing the globals and locals of the context in which
        to run the code. For most intents and purposes you can use the namespace
        dictionary of the <literal>__main__</literal> module for both parameters.
      </para>
      <para>
        Boost.python provides a function to import a module:
      </para>
<programlisting><phrase role="identifier">object</phrase> <phrase role="identifier">import</phrase><phrase role="special">(</phrase><phrase role="identifier">str</phrase> <phrase role="identifier">name</phrase><phrase role="special">)</phrase>
</programlisting>
      <para>
        import imports a python module (potentially loading it into the running process
        first), and returns it.
      </para>
      <para>
        Let's import the <literal>__main__</literal> module and run some Python code
        in its namespace:
      </para>
<programlisting><phrase role="identifier">object</phrase> <phrase role="identifier">main_module</phrase> <phrase role="special">=</phrase> <phrase role="identifier">import</phrase><phrase role="special">(</phrase><phrase role="string">&quot;__main__&quot;</phrase><phrase role="special">);</phrase>
<phrase role="identifier">object</phrase> <phrase role="identifier">main_namespace</phrase> <phrase role="special">=</phrase> <phrase role="identifier">main_module</phrase><phrase role="special">.</phrase><phrase role="identifier">attr</phrase><phrase role="special">(</phrase><phrase role="string">&quot;__dict__&quot;</phrase><phrase role="special">);</phrase>

<phrase role="identifier">object</phrase> <phrase role="identifier">ignored</phrase> <phrase role="special">=</phrase> <phrase role="identifier">exec</phrase><phrase role="special">(</phrase><phrase role="string">&quot;hello = file('hello.txt', 'w')\n&quot;</phrase>
                      <phrase role="string">&quot;hello.write('Hello world!')\n&quot;</phrase>
                      <phrase role="string">&quot;hello.close()&quot;</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">main_namespace</phrase><phrase role="special">);</phrase>
</programlisting>
      <para>
        This should create a file called 'hello.txt' in the current directory containing
        a phrase that is well-known in programming circles.
      </para>
      <bridgehead renderas="sect2" id="tutorial.embedding.using_the_interpreter.h1">
        <phrase id="tutorial.embedding.using_the_interpreter.manipulating_python_objects"/><link
        linkend="tutorial.embedding.using_the_interpreter.manipulating_python_objects">Manipulating
        Python objects</link>
      </bridgehead>
      <para>
        Often we'd like to have a class to manipulate Python objects. But we have
        already seen such a class above, and in the <link linkend="tutorial.object">previous
        section</link>: the aptly named <literal>object</literal> class and its derivatives.
        We've already seen that they can be constructed from a <literal>handle</literal>.
        The following examples should further illustrate this fact:
      </para>
<programlisting><phrase role="identifier">object</phrase> <phrase role="identifier">main_module</phrase> <phrase role="special">=</phrase> <phrase role="identifier">import</phrase><phrase role="special">(</phrase><phrase role="string">&quot;__main__&quot;</phrase><phrase role="special">);</phrase>
<phrase role="identifier">object</phrase> <phrase role="identifier">main_namespace</phrase> <phrase role="special">=</phrase> <phrase role="identifier">main_module</phrase><phrase role="special">.</phrase><phrase role="identifier">attr</phrase><phrase role="special">(</phrase><phrase role="string">&quot;__dict__&quot;</phrase><phrase role="special">);</phrase>
<phrase role="identifier">object</phrase> <phrase role="identifier">ignored</phrase> <phrase role="special">=</phrase> <phrase role="identifier">exec</phrase><phrase role="special">(</phrase><phrase role="string">&quot;result = 5 ** 2&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">main_namespace</phrase><phrase role="special">);</phrase>
<phrase role="keyword">int</phrase> <phrase role="identifier">five_squared</phrase> <phrase role="special">=</phrase> <phrase role="identifier">extract</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">main_namespace</phrase><phrase role="special">[</phrase><phrase role="string">&quot;result&quot;</phrase><phrase role="special">]);</phrase>
</programlisting>
      <para>
        Here we create a dictionary object for the <literal>__main__</literal> module's
        namespace. Then we assign 5 squared to the result variable and read this
        variable from the dictionary. Another way to achieve the same result is to
        use eval instead, which returns the result directly:
      </para>
<programlisting><phrase role="identifier">object</phrase> <phrase role="identifier">result</phrase> <phrase role="special">=</phrase> <phrase role="identifier">eval</phrase><phrase role="special">(</phrase><phrase role="string">&quot;5 ** 2&quot;</phrase><phrase role="special">);</phrase>
<phrase role="keyword">int</phrase> <phrase role="identifier">five_squared</phrase> <phrase role="special">=</phrase> <phrase role="identifier">extract</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">result</phrase><phrase role="special">);</phrase>
</programlisting>
      <bridgehead renderas="sect2" id="tutorial.embedding.using_the_interpreter.h2">
        <phrase id="tutorial.embedding.using_the_interpreter.exception_handling"/><link
        linkend="tutorial.embedding.using_the_interpreter.exception_handling">Exception
        handling</link>
      </bridgehead>
      <para>
        If an exception occurs in the evaluation of the python expression, <ulink
        url="../reference/high_level_components/boost_python_errors_hpp.html#high_level_components.boost_python_errors_hpp.class_error_already_set">error_already_set</ulink>
        is thrown:
      </para>
<programlisting><phrase role="keyword">try</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">object</phrase> <phrase role="identifier">result</phrase> <phrase role="special">=</phrase> <phrase role="identifier">eval</phrase><phrase role="special">(</phrase><phrase role="string">&quot;5/0&quot;</phrase><phrase role="special">);</phrase>
    <phrase role="comment">// execution will never get here:</phrase>
    <phrase role="keyword">int</phrase> <phrase role="identifier">five_divided_by_zero</phrase> <phrase role="special">=</phrase> <phrase role="identifier">extract</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">result</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase>
<phrase role="keyword">catch</phrase><phrase role="special">(</phrase><phrase role="identifier">error_already_set</phrase> <phrase role="keyword">const</phrase> <phrase role="special">&amp;)</phrase>
<phrase role="special">{</phrase>
    <phrase role="comment">// handle the exception in some way</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        The <literal>error_already_set</literal> exception class doesn't carry any
        information in itself. To find out more about the Python exception that occurred,
        you need to use the <ulink url="http://www.python.org/doc/api/exceptionHandling.html">exception
        handling functions</ulink> of the Python C API in your catch-statement. This
        can be as simple as calling <ulink url="http://www.python.org/doc/api/exceptionHandling.html#l2h-70">PyErr_Print()</ulink>
        to print the exception's traceback to the console, or comparing the type
        of the exception with those of the <ulink url="http://www.python.org/doc/api/standardExceptions.html">standard
        exceptions</ulink>:
      </para>
<programlisting><phrase role="keyword">catch</phrase><phrase role="special">(</phrase><phrase role="identifier">error_already_set</phrase> <phrase role="keyword">const</phrase> <phrase role="special">&amp;)</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="identifier">PyErr_ExceptionMatches</phrase><phrase role="special">(</phrase><phrase role="identifier">PyExc_ZeroDivisionError</phrase><phrase role="special">))</phrase>
    <phrase role="special">{</phrase>
        <phrase role="comment">// handle ZeroDivisionError specially</phrase>
    <phrase role="special">}</phrase>
    <phrase role="keyword">else</phrase>
    <phrase role="special">{</phrase>
        <phrase role="comment">// print all other errors to stderr</phrase>
        <phrase role="identifier">PyErr_Print</phrase><phrase role="special">();</phrase>
    <phrase role="special">}</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        (To retrieve even more information from the exception you can use some of
        the other exception handling functions listed <ulink url="http://www.python.org/doc/api/exceptionHandling.html">here</ulink>.)
      </para>
    </section>
  </section>
  <section id="tutorial.iterators">
    <title><link linkend="tutorial.iterators">Iterators</link></title>
    <para>
      In C++, and STL in particular, we see iterators everywhere. Python also has
      iterators, but these are two very different beasts.
    </para>
    <para>
      <emphasis role="bold">C++ iterators:</emphasis>
    </para>
    <itemizedlist>
      <listitem>
        <simpara>
          C++ has 5 type categories (random-access, bidirectional, forward, input,
          output)
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          There are 2 Operation categories: reposition, access
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          A pair of iterators is needed to represent a (first/last) range.
        </simpara>
      </listitem>
    </itemizedlist>
    <para>
      <emphasis role="bold">Python Iterators:</emphasis>
    </para>
    <itemizedlist>
      <listitem>
        <simpara>
          1 category (forward)
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          1 operation category (next())
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          Raises StopIteration exception at end
        </simpara>
      </listitem>
    </itemizedlist>
    <para>
      The typical Python iteration protocol: <literal><emphasis role="bold">for y
      in x...</emphasis></literal> is as follows:
    </para>
<programlisting><phrase role="identifier">iter</phrase> <phrase role="special">=</phrase> <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">__iter__</phrase><phrase role="special">()</phrase>         <phrase role="comment"># get iterator</phrase>
<phrase role="keyword">try</phrase><phrase role="special">:</phrase>
    <phrase role="keyword">while</phrase> <phrase role="number">1</phrase><phrase role="special">:</phrase>
    <phrase role="identifier">y</phrase> <phrase role="special">=</phrase> <phrase role="identifier">iter</phrase><phrase role="special">.</phrase><phrase role="identifier">next</phrase><phrase role="special">()</phrase>         <phrase role="comment"># get each item</phrase>
    <phrase role="special">...</phrase>                     <phrase role="comment"># process y</phrase>
<phrase role="keyword">except</phrase> <phrase role="identifier">StopIteration</phrase><phrase role="special">:</phrase> <phrase role="keyword">pass</phrase>  <phrase role="comment"># iterator exhausted</phrase>
</programlisting>
    <para>
      Boost.Python provides some mechanisms to make C++ iterators play along nicely
      as Python iterators. What we need to do is to produce appropriate <code><phrase
      role="identifier">__iter__</phrase></code> function from C++ iterators that
      is compatible with the Python iteration protocol. For example:
    </para>
<programlisting><phrase role="identifier">object</phrase> <phrase role="identifier">get_iterator</phrase> <phrase role="special">=</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;();</phrase>
<phrase role="identifier">object</phrase> <phrase role="identifier">iter</phrase> <phrase role="special">=</phrase> <phrase role="identifier">get_iterator</phrase><phrase role="special">(</phrase><phrase role="identifier">v</phrase><phrase role="special">);</phrase>
<phrase role="identifier">object</phrase> <phrase role="identifier">first</phrase> <phrase role="special">=</phrase> <phrase role="identifier">iter</phrase><phrase role="special">.</phrase><phrase role="identifier">next</phrase><phrase role="special">();</phrase>
</programlisting>
    <para>
      Or for use in class_&lt;&gt;:
    </para>
<programlisting><phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;__iter__&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;())</phrase>
</programlisting>
    <para>
      <emphasis role="bold">range</emphasis>
    </para>
    <para>
      We can create a Python savvy iterator using the range function:
    </para>
    <itemizedlist>
      <listitem>
        <simpara>
          range(start, finish)
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          range&lt;Policies,Target&gt;(start, finish)
        </simpara>
      </listitem>
    </itemizedlist>
    <para>
      Here, start/finish may be one of:
    </para>
    <itemizedlist>
      <listitem>
        <simpara>
          member data pointers
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          member function pointers
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          adaptable function object (use Target parameter)
        </simpara>
      </listitem>
    </itemizedlist>
    <para>
      <emphasis role="bold">iterator</emphasis>
    </para>
    <itemizedlist>
      <listitem>
        <simpara>
          iterator&lt;T, Policies&gt;()
        </simpara>
      </listitem>
    </itemizedlist>
    <para>
      Given a container <literal>T</literal>, iterator is a shortcut that simply
      calls <literal>range</literal> with &amp;T::begin, &amp;T::end.
    </para>
    <para>
      Let's put this into action... Here's an example from some hypothetical bogon
      Particle accelerator code:
    </para>
<programlisting><phrase role="identifier">f</phrase> <phrase role="special">=</phrase> <phrase role="identifier">Field</phrase><phrase role="special">()</phrase>
<phrase role="keyword">for</phrase> <phrase role="identifier">x</phrase> <phrase role="keyword">in</phrase> <phrase role="identifier">f</phrase><phrase role="special">.</phrase><phrase role="identifier">pions</phrase><phrase role="special">:</phrase>
    <phrase role="identifier">smash</phrase><phrase role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">)</phrase>
<phrase role="keyword">for</phrase> <phrase role="identifier">y</phrase> <phrase role="keyword">in</phrase> <phrase role="identifier">f</phrase><phrase role="special">.</phrase><phrase role="identifier">bogons</phrase><phrase role="special">:</phrase>
    <phrase role="identifier">count</phrase><phrase role="special">(</phrase><phrase role="identifier">y</phrase><phrase role="special">)</phrase>
</programlisting>
    <para>
      Now, our C++ Wrapper:
    </para>
<programlisting><phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">F</phrase><phrase role="special">&gt;(</phrase><phrase role="string">&quot;Field&quot;</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">property</phrase><phrase role="special">(</phrase><phrase role="string">&quot;pions&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">range</phrase><phrase role="special">(&amp;</phrase><phrase role="identifier">F</phrase><phrase role="special">::</phrase><phrase role="identifier">p_begin</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">F</phrase><phrase role="special">::</phrase><phrase role="identifier">p_end</phrase><phrase role="special">))</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">property</phrase><phrase role="special">(</phrase><phrase role="string">&quot;bogons&quot;</phrase><phrase role="special">,</phrase> <phrase role="identifier">range</phrase><phrase role="special">(&amp;</phrase><phrase role="identifier">F</phrase><phrase role="special">::</phrase><phrase role="identifier">b_begin</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">F</phrase><phrase role="special">::</phrase><phrase role="identifier">b_end</phrase><phrase role="special">));</phrase>
</programlisting>
    <para>
      <emphasis role="bold">stl_input_iterator</emphasis>
    </para>
    <para>
      So far, we have seen how to expose C++ iterators and ranges to Python. Sometimes
      we wish to go the other way, though: we'd like to pass a Python sequence to
      an STL algorithm or use it to initialize an STL container. We need to make
      a Python iterator look like an STL iterator. For that, we use <code><phrase
      role="identifier">stl_input_iterator</phrase><phrase role="special">&lt;&gt;</phrase></code>.
      Consider how we might implement a function that exposes <code><phrase role="identifier">std</phrase><phrase
      role="special">::</phrase><phrase role="identifier">list</phrase><phrase role="special">&lt;</phrase><phrase
      role="keyword">int</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">assign</phrase><phrase
      role="special">()</phrase></code> to Python:
    </para>
<programlisting><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">void</phrase> <phrase role="identifier">list_assign</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">list</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">l</phrase><phrase role="special">,</phrase> <phrase role="identifier">object</phrase> <phrase role="identifier">o</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase>
    <phrase role="comment">// Turn a Python sequence into an STL input range</phrase>
    <phrase role="identifier">stl_input_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">o</phrase><phrase role="special">),</phrase> <phrase role="identifier">end</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">l</phrase><phrase role="special">.</phrase><phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">begin</phrase><phrase role="special">,</phrase> <phrase role="identifier">end</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase>

<phrase role="comment">// Part of the wrapper for list&lt;int&gt;</phrase>
<phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">list</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;(</phrase><phrase role="string">&quot;list_int&quot;</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">&quot;assign&quot;</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">list_assign</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">&gt;)</phrase>
    <phrase role="comment">// ...</phrase>
    <phrase role="special">;</phrase>
</programlisting>
    <para>
      Now in Python, we can assign any integer sequence to <code><phrase role="identifier">list_int</phrase></code>
      objects:
    </para>
<programlisting><phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">list_int</phrase><phrase role="special">();</phrase>
<phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">assign</phrase><phrase role="special">([</phrase><phrase role="number">1</phrase><phrase role="special">,</phrase><phrase role="number">2</phrase><phrase role="special">,</phrase><phrase role="number">3</phrase><phrase role="special">,</phrase><phrase role="number">4</phrase><phrase role="special">,</phrase><phrase role="number">5</phrase><phrase role="special">])</phrase>
</programlisting>
  </section>
  <section id="tutorial.exception">
    <title><link linkend="tutorial.exception">Exception Translation</link></title>
    <para>
      All C++ exceptions must be caught at the boundary with Python code. This boundary
      is the point where C++ meets Python. Boost.Python provides a default exception
      handler that translates selected standard exceptions, then gives up:
    </para>
<programlisting><phrase role="keyword">raise</phrase> <phrase role="identifier">RuntimeError</phrase><phrase role="special">,</phrase> <phrase role="string">'unidentifiable C++ Exception'</phrase>
</programlisting>
    <para>
      Users may provide custom translation. Here's an example:
    </para>
<programlisting><phrase role="identifier">struct</phrase> <phrase role="identifier">PodBayDoorException</phrase><phrase role="special">;</phrase>
<phrase role="identifier">void</phrase> <phrase role="identifier">translator</phrase><phrase role="special">(</phrase><phrase role="identifier">PodBayDoorException</phrase> <phrase role="identifier">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase>
    <phrase role="identifier">PyErr_SetString</phrase><phrase role="special">(</phrase><phrase role="identifier">PyExc_UserWarning</phrase><phrase role="special">,</phrase> <phrase role="string">&quot;I'm sorry Dave...&quot;</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase>
<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">kubrick</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase>
     <phrase role="identifier">register_exception_translator</phrase><phrase role="special">&lt;</phrase>
          <phrase role="identifier">PodBayDoorException</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">translator</phrase><phrase role="special">);</phrase>
     <phrase role="special">...</phrase>
</programlisting>
  </section>
  <section id="tutorial.techniques">
    <title><link linkend="tutorial.techniques">General Techniques</link></title>
    <para>
      Here are presented some useful techniques that you can use while wrapping code
      with Boost.Python.
    </para>
    <section id="tutorial.techniques.creating_packages">
      <title><link linkend="tutorial.techniques.creating_packages">Creating Packages</link></title>
      <para>
        A Python package is a collection of modules that provide to the user a certain
        functionality. If you're not familiar on how to create packages, a good introduction
        to them is provided in the <ulink url="http://www.python.org/doc/current/tut/node8.html">Python
        Tutorial</ulink>.
      </para>
      <para>
        But we are wrapping C++ code, using Boost.Python. How can we provide a nice
        package interface to our users? To better explain some concepts, let's work
        with an example.
      </para>
      <para>
        We have a C++ library that works with sounds: reading and writing various
        formats, applying filters to the sound data, etc. It is named (conveniently)
        <literal>sounds</literal>. Our library already has a neat C++ namespace hierarchy,
        like so:
      </para>
<programlisting><phrase role="identifier">sounds</phrase><phrase role="special">::</phrase><phrase role="identifier">core</phrase>
<phrase role="identifier">sounds</phrase><phrase role="special">::</phrase><phrase role="identifier">io</phrase>
<phrase role="identifier">sounds</phrase><phrase role="special">::</phrase><phrase role="identifier">filters</phrase>
</programlisting>
      <para>
        We would like to present this same hierarchy to the Python user, allowing
        him to write code like this:
      </para>
<programlisting><phrase role="keyword">import</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">filters</phrase>
<phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">filters</phrase><phrase role="special">.</phrase><phrase role="identifier">echo</phrase><phrase role="special">(...)</phrase> <phrase role="comment"># echo is a C++ function</phrase>
</programlisting>
      <para>
        The first step is to write the wrapping code. We have to export each module
        separately with Boost.Python, like this:
      </para>
<programlisting><phrase role="special">/*</phrase> <phrase role="identifier">file</phrase> <phrase role="identifier">core</phrase><phrase role="special">.</phrase><phrase role="identifier">cpp</phrase> <phrase role="special">*/</phrase>
<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">core</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="special">/*</phrase> <phrase role="identifier">export</phrase> <phrase role="identifier">everything</phrase> <phrase role="keyword">in</phrase> <phrase role="identifier">the</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">::</phrase><phrase role="identifier">core</phrase> <phrase role="identifier">namespace</phrase> <phrase role="special">*/</phrase>
    <phrase role="special">...</phrase>
<phrase role="special">}</phrase>

<phrase role="special">/*</phrase> <phrase role="identifier">file</phrase> <phrase role="identifier">io</phrase><phrase role="special">.</phrase><phrase role="identifier">cpp</phrase> <phrase role="special">*/</phrase>
<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">io</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="special">/*</phrase> <phrase role="identifier">export</phrase> <phrase role="identifier">everything</phrase> <phrase role="keyword">in</phrase> <phrase role="identifier">the</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">::</phrase><phrase role="identifier">io</phrase> <phrase role="identifier">namespace</phrase> <phrase role="special">*/</phrase>
    <phrase role="special">...</phrase>
<phrase role="special">}</phrase>

<phrase role="special">/*</phrase> <phrase role="identifier">file</phrase> <phrase role="identifier">filters</phrase><phrase role="special">.</phrase><phrase role="identifier">cpp</phrase> <phrase role="special">*/</phrase>
<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">filters</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="special">/*</phrase> <phrase role="identifier">export</phrase> <phrase role="identifier">everything</phrase> <phrase role="keyword">in</phrase> <phrase role="identifier">the</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">::</phrase><phrase role="identifier">filters</phrase> <phrase role="identifier">namespace</phrase> <phrase role="special">*/</phrase>
    <phrase role="special">...</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        Compiling these files will generate the following Python extensions: <literal>core.pyd</literal>,
        <literal>io.pyd</literal> and <literal>filters.pyd</literal>.
      </para>
      <note>
        <para>
          The extension <literal>.pyd</literal> is used for python extension modules,
          which are just shared libraries. Using the default for your system, like
          <literal>.so</literal> for Unix and <literal>.dll</literal> for Windows,
          works just as well.
        </para>
      </note>
      <para>
        Now, we create this directory structure for our Python package:
      </para>
<programlisting>sounds/
    __init__.py
    core.pyd
    filters.pyd
    io.pyd
</programlisting>
      <para>
        The file <literal>__init__.py</literal> is what tells Python that the directory
        <literal>sounds/</literal> is actually a Python package. It can be a empty
        file, but can also perform some magic, that will be shown later.
      </para>
      <para>
        Now our package is ready. All the user has to do is put <literal>sounds</literal>
        into his <ulink url="http://www.python.org/doc/current/tut/node8.html#SECTION008110000000000000000">PYTHONPATH</ulink>
        and fire up the interpreter:
      </para>
<programlisting><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">import</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">io</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">import</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">filters</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">sound</phrase> <phrase role="special">=</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">io</phrase><phrase role="special">.</phrase><phrase role="identifier">open</phrase><phrase role="special">(</phrase><phrase role="string">'file.mp3'</phrase><phrase role="special">)</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">new_sound</phrase> <phrase role="special">=</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">filters</phrase><phrase role="special">.</phrase><phrase role="identifier">echo</phrase><phrase role="special">(</phrase><phrase role="identifier">sound</phrase><phrase role="special">,</phrase> <phrase role="number">1.0</phrase><phrase role="special">)</phrase>
</programlisting>
      <para>
        Nice heh?
      </para>
      <para>
        This is the simplest way to create hierarchies of packages, but it is not
        very flexible. What if we want to add a <emphasis>pure</emphasis> Python
        function to the filters package, for instance, one that applies 3 filters
        in a sound object at once? Sure, you can do this in C++ and export it, but
        why not do so in Python? You don't have to recompile the extension modules,
        plus it will be easier to write it.
      </para>
      <para>
        If we want this flexibility, we will have to complicate our package hierarchy
        a little. First, we will have to change the name of the extension modules:
      </para>
<programlisting><phrase role="comment">/* file core.cpp */</phrase>
<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">_core</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="special">...</phrase>
    <phrase role="comment">/* export everything in the sounds::core namespace */</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        Note that we added an underscore to the module name. The filename will have
        to be changed to <literal>_core.pyd</literal> as well, and we do the same
        to the other extension modules. Now, we change our package hierarchy like
        so:
      </para>
<programlisting>sounds/
    __init__.py
    core/
        __init__.py
        _core.pyd
    filters/
        __init__.py
        _filters.pyd
    io/
        __init__.py
        _io.pyd
</programlisting>
      <para>
        Note that we created a directory for each extension module, and added a __init__.py
        to each one. But if we leave it that way, the user will have to access the
        functions in the core module with this syntax:
      </para>
<programlisting><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">import</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">core</phrase><phrase role="special">.</phrase><phrase role="identifier">_core</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">core</phrase><phrase role="special">.</phrase><phrase role="identifier">_core</phrase><phrase role="special">.</phrase><phrase role="identifier">foo</phrase><phrase role="special">(...)</phrase>
</programlisting>
      <para>
        which is not what we want. But here enters the <literal>__init__.py</literal>
        magic: everything that is brought to the <literal>__init__.py</literal> namespace
        can be accessed directly by the user. So, all we have to do is bring the
        entire namespace from <literal>_core.pyd</literal> to <literal>core/__init__.py</literal>.
        So add this line of code to <literal>sounds/core/__init__.py</literal>:
      </para>
<programlisting><phrase role="keyword">from</phrase> <phrase role="identifier">_core</phrase> <phrase role="keyword">import</phrase> <phrase role="special">*</phrase>
</programlisting>
      <para>
        We do the same for the other packages. Now the user accesses the functions
        and classes in the extension modules like before:
      </para>
<programlisting><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">import</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">filters</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">filters</phrase><phrase role="special">.</phrase><phrase role="identifier">echo</phrase><phrase role="special">(...)</phrase>
</programlisting>
      <para>
        with the additional benefit that we can easily add pure Python functions
        to any module, in a way that the user can't tell the difference between a
        C++ function and a Python function. Let's add a <emphasis>pure</emphasis>
        Python function, <literal>echo_noise</literal>, to the <literal>filters</literal>
        package. This function applies both the <literal>echo</literal> and <literal>noise</literal>
        filters in sequence in the given <literal>sound</literal> object. We create
        a file named <literal>sounds/filters/echo_noise.py</literal> and code our
        function:
      </para>
<programlisting><phrase role="keyword">import</phrase> <phrase role="identifier">_filters</phrase>
<phrase role="keyword">def</phrase> <phrase role="identifier">echo_noise</phrase><phrase role="special">(</phrase><phrase role="identifier">sound</phrase><phrase role="special">):</phrase>
    <phrase role="identifier">s</phrase> <phrase role="special">=</phrase> <phrase role="identifier">_filters</phrase><phrase role="special">.</phrase><phrase role="identifier">echo</phrase><phrase role="special">(</phrase><phrase role="identifier">sound</phrase><phrase role="special">)</phrase>
    <phrase role="identifier">s</phrase> <phrase role="special">=</phrase> <phrase role="identifier">_filters</phrase><phrase role="special">.</phrase><phrase role="identifier">noise</phrase><phrase role="special">(</phrase><phrase role="identifier">sound</phrase><phrase role="special">)</phrase>
    <phrase role="keyword">return</phrase> <phrase role="identifier">s</phrase>
</programlisting>
      <para>
        Next, we add this line to <literal>sounds/filters/__init__.py</literal>:
      </para>
<programlisting><phrase role="keyword">from</phrase> <phrase role="identifier">echo_noise</phrase> <phrase role="keyword">import</phrase> <phrase role="identifier">echo_noise</phrase>
</programlisting>
      <para>
        And that's it. The user now accesses this function like any other function
        from the <literal>filters</literal> package:
      </para>
<programlisting><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">import</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">filters</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">filters</phrase><phrase role="special">.</phrase><phrase role="identifier">echo_noise</phrase><phrase role="special">(...)</phrase>
</programlisting>
    </section>
    <section id="tutorial.techniques.extending_wrapped_objects_in_pyt">
      <title><link linkend="tutorial.techniques.extending_wrapped_objects_in_pyt">Extending
      Wrapped Objects in Python</link></title>
      <para>
        Thanks to Python's flexibility, you can easily add new methods to a class,
        even after it was already created:
      </para>
<programlisting><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">C</phrase><phrase role="special">(</phrase><phrase role="identifier">object</phrase><phrase role="special">):</phrase> <phrase role="keyword">pass</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="comment"># a regular function</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">def</phrase> <phrase role="identifier">C_str</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">):</phrase> <phrase role="keyword">return</phrase> <phrase role="string">'A C instance!'</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="comment"># now we turn it in a member function</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">C</phrase><phrase role="special">.</phrase><phrase role="identifier">__str__</phrase> <phrase role="special">=</phrase> <phrase role="identifier">C_str</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">c</phrase> <phrase role="special">=</phrase> <phrase role="identifier">C</phrase><phrase role="special">()</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">print</phrase> <phrase role="identifier">c</phrase>
<phrase role="identifier">A</phrase> <phrase role="identifier">C</phrase> <phrase role="identifier">instance</phrase><phrase role="special">!</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">C_str</phrase><phrase role="special">(</phrase><phrase role="identifier">c</phrase><phrase role="special">)</phrase>
<phrase role="identifier">A</phrase> <phrase role="identifier">C</phrase> <phrase role="identifier">instance</phrase><phrase role="special">!</phrase>
</programlisting>
      <para>
        Yes, Python rox. <inlinemediaobject><imageobject><imagedata fileref="../images/smiley.png"></imagedata></imageobject></inlinemediaobject>
      </para>
      <para>
        We can do the same with classes that were wrapped with Boost.Python. Suppose
        we have a class <literal>point</literal> in C++:
      </para>
<programlisting><phrase role="keyword">class</phrase> <phrase role="identifier">point</phrase> <phrase role="special">{...};</phrase>

<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">_geom</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">point</phrase><phrase role="special">&gt;(</phrase><phrase role="string">&quot;point&quot;</phrase><phrase role="special">)...;</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        If we are using the technique from the previous session, <link linkend="tutorial.techniques.creating_packages">Creating
        Packages</link>, we can code directly into <literal>geom/__init__.py</literal>:
      </para>
<programlisting><phrase role="keyword">from</phrase> <phrase role="identifier">_geom</phrase> <phrase role="keyword">import</phrase> <phrase role="special">*</phrase>

<phrase role="comment"># a regular function</phrase>
<phrase role="keyword">def</phrase> <phrase role="identifier">point_str</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">):</phrase>
    <phrase role="keyword">return</phrase> <phrase role="identifier">str</phrase><phrase role="special">((</phrase><phrase role="identifier">self</phrase><phrase role="special">.</phrase><phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">self</phrase><phrase role="special">.</phrase><phrase role="identifier">y</phrase><phrase role="special">))</phrase>

<phrase role="comment"># now we turn it into a member function</phrase>
<phrase role="identifier">point</phrase><phrase role="special">.</phrase><phrase role="identifier">__str__</phrase> <phrase role="special">=</phrase> <phrase role="identifier">point_str</phrase>
</programlisting>
      <para>
        <emphasis role="bold">All</emphasis> point instances created from C++ will
        also have this member function! This technique has several advantages:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            Cut down compile times to zero for these additional functions
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Reduce the memory footprint to virtually zero
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Minimize the need to recompile
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Rapid prototyping (you can move the code to C++ if required without changing
            the interface)
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        You can even add a little syntactic sugar with the use of metaclasses. Let's
        create a special metaclass that &quot;injects&quot; methods in other classes.
      </para>
<programlisting><phrase role="comment"># The one Boost.Python uses for all wrapped classes.</phrase>
<phrase role="comment"># You can use here any class exported by Boost instead of &quot;point&quot;</phrase>
<phrase role="identifier">BoostPythonMetaclass</phrase> <phrase role="special">=</phrase> <phrase role="identifier">point</phrase><phrase role="special">.</phrase><phrase role="identifier">__class__</phrase>

<phrase role="keyword">class</phrase> <phrase role="identifier">injector</phrase><phrase role="special">(</phrase><phrase role="identifier">object</phrase><phrase role="special">):</phrase>
    <phrase role="keyword">class</phrase> <phrase role="identifier">__metaclass__</phrase><phrase role="special">(</phrase><phrase role="identifier">BoostPythonMetaclass</phrase><phrase role="special">):</phrase>
        <phrase role="keyword">def</phrase> <phrase role="identifier">__init__</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">,</phrase> <phrase role="identifier">name</phrase><phrase role="special">,</phrase> <phrase role="identifier">bases</phrase><phrase role="special">,</phrase> <phrase role="identifier">dict</phrase><phrase role="special">):</phrase>
            <phrase role="keyword">for</phrase> <phrase role="identifier">b</phrase> <phrase role="keyword">in</phrase> <phrase role="identifier">bases</phrase><phrase role="special">:</phrase>
                <phrase role="keyword">if</phrase> <phrase role="identifier">type</phrase><phrase role="special">(</phrase><phrase role="identifier">b</phrase><phrase role="special">)</phrase> <phrase role="keyword">not</phrase> <phrase role="keyword">in</phrase> <phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">,</phrase> <phrase role="identifier">type</phrase><phrase role="special">):</phrase>
                    <phrase role="keyword">for</phrase> <phrase role="identifier">k</phrase><phrase role="special">,</phrase><phrase role="identifier">v</phrase> <phrase role="keyword">in</phrase> <phrase role="identifier">dict</phrase><phrase role="special">.</phrase><phrase role="identifier">items</phrase><phrase role="special">():</phrase>
                        <phrase role="identifier">setattr</phrase><phrase role="special">(</phrase><phrase role="identifier">b</phrase><phrase role="special">,</phrase><phrase role="identifier">k</phrase><phrase role="special">,</phrase><phrase role="identifier">v</phrase><phrase role="special">)</phrase>
            <phrase role="keyword">return</phrase> <phrase role="identifier">type</phrase><phrase role="special">.</phrase><phrase role="identifier">__init__</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">,</phrase> <phrase role="identifier">name</phrase><phrase role="special">,</phrase> <phrase role="identifier">bases</phrase><phrase role="special">,</phrase> <phrase role="identifier">dict</phrase><phrase role="special">)</phrase>

<phrase role="comment"># inject some methods in the point foo</phrase>
<phrase role="keyword">class</phrase> <phrase role="identifier">more_point</phrase><phrase role="special">(</phrase><phrase role="identifier">injector</phrase><phrase role="special">,</phrase> <phrase role="identifier">point</phrase><phrase role="special">):</phrase>
    <phrase role="keyword">def</phrase> <phrase role="identifier">__repr__</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">):</phrase>
        <phrase role="keyword">return</phrase> <phrase role="string">'Point(x=%s, y=%s)'</phrase> <phrase role="special">%</phrase> <phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">.</phrase><phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">self</phrase><phrase role="special">.</phrase><phrase role="identifier">y</phrase><phrase role="special">)</phrase>
    <phrase role="keyword">def</phrase> <phrase role="identifier">foo</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">):</phrase>
        <phrase role="keyword">print</phrase> <phrase role="string">'foo!'</phrase>
</programlisting>
      <para>
        Now let's see how it got:
      </para>
<programlisting><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">print</phrase> <phrase role="identifier">point</phrase><phrase role="special">()</phrase>
<phrase role="identifier">Point</phrase><phrase role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">=</phrase><phrase role="number">10</phrase><phrase role="special">,</phrase> <phrase role="identifier">y</phrase><phrase role="special">=</phrase><phrase role="number">10</phrase><phrase role="special">)</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">point</phrase><phrase role="special">().</phrase><phrase role="identifier">foo</phrase><phrase role="special">()</phrase>
<phrase role="identifier">foo</phrase><phrase role="special">!</phrase>
</programlisting>
      <para>
        Another useful idea is to replace constructors with factory functions:
      </para>
<programlisting><phrase role="identifier">_point</phrase> <phrase role="special">=</phrase> <phrase role="identifier">point</phrase>

<phrase role="keyword">def</phrase> <phrase role="identifier">point</phrase><phrase role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">=</phrase><phrase role="number">0</phrase><phrase role="special">,</phrase> <phrase role="identifier">y</phrase><phrase role="special">=</phrase><phrase role="number">0</phrase><phrase role="special">):</phrase>
    <phrase role="keyword">return</phrase> <phrase role="identifier">_point</phrase><phrase role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">y</phrase><phrase role="special">)</phrase>
</programlisting>
      <para>
        In this simple case there is not much gained, but for constructurs with many
        overloads and/or arguments this is often a great simplification, again with
        virtually zero memory footprint and zero compile-time overhead for the keyword
        support.
      </para>
    </section>
    <section id="tutorial.techniques.reducing_compiling_time">
      <title><link linkend="tutorial.techniques.reducing_compiling_time">Reducing
      Compiling Time</link></title>
      <para>
        If you have ever exported a lot of classes, you know that it takes quite
        a good time to compile the Boost.Python wrappers. Plus the memory consumption
        can easily become too high. If this is causing you problems, you can split
        the class_ definitions in multiple files:
      </para>
<programlisting><phrase role="comment">/* file point.cpp */</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">point</phrase><phrase role="special">.</phrase><phrase role="identifier">h</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">python</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">void</phrase> <phrase role="identifier">export_point</phrase><phrase role="special">()</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">point</phrase><phrase role="special">&gt;(</phrase><phrase role="string">&quot;point&quot;</phrase><phrase role="special">)...;</phrase>
<phrase role="special">}</phrase>

<phrase role="comment">/* file triangle.cpp */</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">triangle</phrase><phrase role="special">.</phrase><phrase role="identifier">h</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">python</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">void</phrase> <phrase role="identifier">export_triangle</phrase><phrase role="special">()</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">triangle</phrase><phrase role="special">&gt;(</phrase><phrase role="string">&quot;triangle&quot;</phrase><phrase role="special">)...;</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        Now you create a file <literal>main.cpp</literal>, which contains the <literal>BOOST_PYTHON_MODULE</literal>
        macro, and call the various export functions inside it.
      </para>
<programlisting><phrase role="keyword">void</phrase> <phrase role="identifier">export_point</phrase><phrase role="special">();</phrase>
<phrase role="keyword">void</phrase> <phrase role="identifier">export_triangle</phrase><phrase role="special">();</phrase>

<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">_geom</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">export_point</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">export_triangle</phrase><phrase role="special">();</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        Compiling and linking together all this files produces the same result as
        the usual approach:
      </para>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">python</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">point</phrase><phrase role="special">.</phrase><phrase role="identifier">h</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">triangle</phrase><phrase role="special">.</phrase><phrase role="identifier">h</phrase><phrase role="special">&gt;</phrase>

<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">_geom</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">point</phrase><phrase role="special">&gt;(</phrase><phrase role="string">&quot;point&quot;</phrase><phrase role="special">)...;</phrase>
    <phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">triangle</phrase><phrase role="special">&gt;(</phrase><phrase role="string">&quot;triangle&quot;</phrase><phrase role="special">)...;</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        but the memory is kept under control.
      </para>
      <para>
        This method is recommended too if you are developing the C++ library and
        exporting it to Python at the same time: changes in a class will only demand
        the compilation of a single cpp, instead of the entire wrapper code.
      </para>
      <note>
        <para>
          This method is useful too if you are getting the error message <emphasis>&quot;fatal
          error C1204:Compiler limit:internal structure overflow&quot;</emphasis>
          when compiling a large source file, as explained in the <ulink url="../faq/fatal_error_c1204_compiler_limit.html">FAQ</ulink>.
        </para>
      </note>
    </section>
  </section>
</article>
